\subsection{Different less-or-equal operators}
%\subsubsection{Subset operator}
\label{sec:leqOperators}
The less-or-equal operator is the operator executed the most often during analyses as $\cpaStop^{sep}$ uses it once for every state in the reached set, at every iteration of the CPA algorithm.
In addition, it is responsible for determining whether a new state is already covered and analysis can be stopped at this point.
Because of this, its speed and precision can make a great difference for the performance of our analysis.

The  less-or-equal operators we used for \symbolicValueAnalysisCPA\ and \constraintsCPA\ using an \aliasFunc\ function try to be more precise than a simple subset check.
Aliasing proves only useful, though, when a non-deterministical value is assigned in a loop. A simple example can be seen in Figure \ref{fig:loopNondetAssign1}.
After the first iteration of the loop, an abstract variable assignment $v = \{ a \rightarrow s1 \}$ exists in the reached set, with $s1 \in \symIds$.
At the second iteration of the loop, the new abstract variable assignment $v' = \{ a \rightarrow s2 \}$ with $s2 \in \symIds$ is created, but not added to the reached set, since $\cpaStop^{sep}(v', \{ v \}, \pi) = true$ since $v' \lesserEqual v$ using the aliasing less-or-equal operator.

This is only useful as long as no variables are both assigned values and accessed inside the loop, as the next example shows. In Figure \ref{fig:loopNondetAssign2}\ a second program variable, \textbf{b}, gets assigned a non-deterministic value outside the loop, which is used inside the loop to compute a new value for \textbf{b}.
After the first iteration of the loop, an abstract variable assignment $v = \{ a \rightarrow s1, b \rightarrow s2 + 1 \}$ is part of the reached set.
At the second iteration, a second abstract variable assignment $v' = \{ a \rightarrow s3, b \rightarrow s2 + 2 \}$ is created and no fitting alias can be found because of $s2 + 1$ not fitting $s2 + 2$.
A new abstract variable assignment is added like this at every new loop.
Because of this strong restriction, we assume that the aliasing proves useful in only few cases.

\begin{figure}[t]
\begin{subfigure}[b]{.48\textwidth}
\begin{tikzpicture}[->,>=stealth, mynode/.style={circle, draw, minimum size=0.5cm}, every node/.style={font=\small}]

\node[mynode] (0) {$l_0$};
\node[mynode] (2) [below = 0.6cm of 1] {$l_2$};

\path
  (0) edge node [right] {\textbf{a $\assign$ \_\_nondet\_int()}} (2)
  (2) edge [bend left] (0);
\end{tikzpicture}
\caption{An example CFA}
\label{fig:loopNondetAssign1}
\end{subfigure}%
\hfill
\begin{subfigure}[b]{.48\textwidth}
\begin{tikzpicture}[->,>=stealth, mynode/.style={circle, draw, minimum size=0.5cm}, every node/.style={font=\small}]

\node[mynode] (0) {$l_0$};
\node[mynode] (1) [below = 0.6cm of 0] {$l_1$};
\node[mynode] (2) [below = 0.6cm of 1] {$l_2$};
\node[mynode] (3) [below = 0.6cm of 2] {$l_3$};
\path
  (0) edge node [right] {\textbf{b $\assign$ \_\_nondet\_int()}} (1)
  (1) edge node [right] {\textbf{a $\assign$ \_\_nondet\_int()}} (2)
  (2) edge node [right] {\textbf{b $\assign \textbf{b} + 1$}} (3)
  (3) edge [bend left] (1);
\end{tikzpicture}
\caption{An example CFA}
\label{fig:loopNondetAssign2}
\end{subfigure}
\caption{Two CFAs with non-deterministic assignments in a loop}
\end{figure}

Additionally, the computation of this \aliasFunc\ function increases the complexity of the operator to a high degree (depending on data-structures and the used algorithm).
It is worth evaluating a simple subset check as less-or-equal operator to see whether the aliasing's higher precision in some special cases actually justifies its lower performance.
The simple less-or-equal operator performing a subset check for the \symbolicValueAnalysisCPA\ is defined as $v \lesserEqualSub v'$ if $v \supseteq v'$
and for the \constraintsCPA\ it is defined as $a \lesserEqualSub a'$ if $a \supseteq a'$.

%\subsubsection{Implication operator}
Since a \constraintsCPA 's abstract state $a$ is interpreted as the conjunction of its constraints $\varphi_a$, it seems fit to use implication as the less-or-equal operator.
Remember that $\llbracket a \rrbracket = \{ c \in C |\ c \satisfies \varphi_a \}$.
If a formula $\varphi_a$ implies a formula $\varphi_{a'}$ and $c$ satisfies $\varphi_a$, then $c$ also satisfies $\varphi_{a'}$.
Because of this 
\[\llbracket a \rrbracket = \{ c \in C |\ c \satisfies \varphi_a \} \subseteq \{ c \in C |\ c \satisfies \varphi_{a'} \} = \llbracket a' \rrbracket \text{ if } \varphi_a \Rightarrow \varphi_{a'}.\]
The less-or-equal operator for the \constraintsCPA\ using implication is defined as $a \lesserEqualImpl a'$ if $\varphi_a \Rightarrow \varphi_{a'}$.
This operator has a higher precision than $\lesserEqualSub$ and a higher one than the aliasing less-or-equal operator as long as no aliasing is necessary/possible, but requires SAT checks, which are definitely worse in performance than merely checking whether one set is the subset of another.
If aliasing is possible for proving a less-or-equal relation, though, we can't compare implication to the aliasing less-or-equal operator directly.
Implication handles symbolic identifiers as variables and as such will not be able to prove $a \Rightarrow a'$ if $a'$ contains any variable not contained in $a$.


