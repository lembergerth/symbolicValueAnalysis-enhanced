\chapter{Conclusion}
We successfully designed and implemented a refinement procedure to use symbolic execution with CEGAR in the context of configurable software verification.
To our knowledge, we were the first to apply CEGAR to symbolic execution.
In addition, we applied CEGAR not to one single domain, but to two strongly intertwined domains at once, by combining the \symbolicValueAnalysisCPA\ and the \constraintsCPA\ to represent the semantics of symbolic execution.
As a second and to our knowledge novel approach we utilized the refinement procedure of another domain, namely predicate analysis, to derive a precision for our symbolic execution domain.
Both approaches to refinement yielded comparable results.
We evaluated two different less-or-equal operators and two different precision types for the \constraintsCPA\ and illustrated their differences.

Additionally, we refactored \valueAnalysisCPA\ implementation's refinement procedure to be more generic.
The now generic refinement procedure allows the implementation of new refinement procedures with low effort, in contrast to the previous need for a full implementation.
This also allowed us to apply advanced features like sliced prefix selection to our new refinement procedure without any additional changes.

Evaluation shows the competitive performance of symbolic execution, being more reliable than value analysis and almost as effective as predicate analysis.
Since it is possible to explicitly distinguish between concrete and symbolic (i.e. non-deterministic) values, symbolic execution might prove useful for test generation, too.
Symbolic execution in the context of configurable software verification and especially in combination with CEGAR shows potential for software verification that should be build on to be able to verify even more programs.
