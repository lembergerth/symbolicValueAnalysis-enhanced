\subsection{General Overview of configurable program analysis}
\begin{figure}
\lstset{numbers=left}
\begin{subfigure}[b]{.48\textwidth}
\lstinputlisting[language=C]{exampleProgram.c}
\end{subfigure}%
\hfill
\begin{subfigure}[b]{.48\textwidth}
\begin{tikzpicture}[->,>=stealth, mynode/.style={circle, draw, minimum size=0.5cm}, every node/.style={font=\small}]

  \node[mynode] (1) {4};
  \node[mynode] (2) [below = 0.6cm of 1]{7};
  \node[mynode] (3) [below left = 1.2cm of 2]{11};
  \node[mynode] (4) [below right = 1.2cm of 2]{8};
  \node[mynode] (5) [below = 0.5cm of 3]{12};
  \node[mynode] (6) [below = 0.5cm of 4]{10};
  \node[mynode] (7) [below right = 1.2cm of 5]{14};
  \node[mynode] (8) [below left = 1cm of 7]{17};
  \node[mynode] (9) [below right = 1cm of 7]{16};

  \path
    (1) edge node [right] {\textbf{a $\assign$ \_\_nondet\_int()}} (2)
    (2) edge node [left, pos=0.5] {$\mathbf{[!(a \geq 0)]}$} (3)
    (2) edge node [right, pos=0.5] {$\mathbf{[a \geq 0]}$} (4)
    (3) edge node [left] {\textbf{b $\assign$ a + 1}} (5)
    (4) edge node [right] {\textbf{b $\assign$ a}} (6)
    (5) edge (7)
    (6) edge (7)
    (7) edge node [left] {$\mathbf{[!(b < a)]}$} (8)
    (7) edge node [right] {$\mathbf{[b < a]}$} (9)
  ;
\end{tikzpicture}
\end{subfigure}
\caption{An example CFA.}
\label{fig:exCFA}
\end{figure}

For the sake of simplicity, we focus on a programming language that only consists of variable assignments (e.g. $x \assign 5$ or $y \assign x$) and assumptions (e.g. $[x > 5]$ or $[y < x]$).
All values are integers.
We represent a program by a \emph{control flow automaton} (CFA) \cite{BeyerBook}\cite{Beyer2012}.
A CFA $A = (L, l_0, G)$ is a directed graph whose nodes $L$ represent the program locations of the program.
The initial node $l_0 \in L$ represents the program entry.
An edge $g \in G \subseteq L \times Ops \times L$ exists between two nodes if a program statement exists that transfers control between the program locations represented by the nodes.
Each edge is labeled with the operation that transfers the control.
If a node has no leaving edges it is a final node. Final nodes represent the program exit.
A CFA for the previously mentioned example program can be seen in Figure \ref{fig:exCFA}.
A \emph{path} $\sigma$ \cite{Beyer2015} is a sequence $\langle (op_1, l_1), ..., (op_n, l_n)$ of program locations and their corresponding operations.
A path $\sigma$ is a \emph{program path}, if $\sigma$ represents a syntactic walk through the CFA, that means for every $1 \leq i \leq n$ a CFA edge $g = (l_{i-1}, op_i, l_i)$ exists and $l_0$ is the initial program location.
Every path $\sigma = \langle (op_1, l_1), ..., (op_n, l_n) \rangle$ defines a \emph{constraint sequence} $\gamma_\sigma = \langle op_1, ..., op_n \rangle$.
The \emph{conjunction} of two constraint sequences $\gamma = \langle op_1, ..., op_n \rangle$ and $\gamma' = \langle op'_1, .., op'_n \rangle$ is defined as their concatenation,
that means $\gamma \logicAnd \gamma' = \langle op_1, ..., op_n, op'_1, ..., op'_n \rangle$.
The set $X$ is the set of all program variables occurring in a program.

The basis of automatic software verification is the reachability problem: For a given specification it is derived whether a program state is reachable that violates this specification.
Traditionally, two major approaches exist, both working on a reachability tree: Model checking and program analysis, sometimes called data flow analysis.
While model checking is mostly concerned with finding a program abstraction with a precision high enough to eliminate false alarms,
which in turn only allows it to handle small programs because of poor performance,
program analysis tries to reach high efficiency by looking at only a few chosen characteristics of a program. %\cite{Beyer2007}%cite here or below? out of lecture notes, so cite in some other way? 
It does so by using abstract states of a specific, chosen abstract domain to abstract from concrete program states.

%\subsubsection{Concrete state definition}
A concrete state $c$ is a total function $c: X \cup \{pc\} \rightarrow \integerset$ that assigns a specific value of $\integerset$ to every program variable $x \in X$ and to the program counter $pc$. The program counter $pc$ represents the current location in the program.
The set of all concrete states of a program is $C$. A set $r \subseteq C$ is called a \emph{region}.
For the reachability problem the region of concrete states that violate a given specification is called the \emph{target region} $\targetRegion$.

%\subsubsection{Abstract state definition}
An abstract domain \cite{Beyer2007} $D = (C, \semilattice, \concretization)$ consists of a set of possible concrete states $C$, a semi-lattice $\semilattice$ that describes the abstract states and their possible relation to each other and a concretization function $\concretization : \semilattice \rightarrow 2^C$ which maps each element of $\semilattice$ to a subset of $C$.

A semi-lattice $\semilattice = (E, \top, \bot, \lesserEqual, \join)$ consists of a set $E$ of elements, a top element $\top \in E$, a partial order $\lesserEqual\ \subseteq (E \times E)$
and the total function $\join : (E \times E) \rightarrow E$ called join operator.

Program analysis starts with an initial abstract state, usually $\top$, and uses a transfer relation to derive new abstract states from old abstract states and program statements.
A transfer relation \cite{Beyer2007} $\transfer\ \subseteq (E \times G \times E)$ assigns to each abstract state $e \in E$ possible abstract successors $e' \in E$. $G$ is the set of all program statements.
For every program statement $g \in G$ we write $e \gtransfer e'$ if $(e, g, e') \in \gtransfer$ and $e \transfer e'$ if a program statement $g$ with $e \gtransfer e'$ exists.

For soundness (i.e. if a property violation exists, it is always found) and progress of the program analysis, the following requirements have to be fulfilled:\cite{Beyer2007}
\begin{enumerate}[label=\alph*)]
\item the top element of abstract states has to represent all possible concrete states and the bottom element must represent none, formally put $\llbracket \top \rrbracket = C$ and $\llbracket \bot \rrbracket = \varnothing$,
\item the join operator has to be precise or over-approximating. That means the join of two abstractes states always has to represent the same or more concrete states than the union of the concrete states both abstract states represent. This can be formally expressed as $\forall e, e' \in E: \llbracket e \join e' \rrbracket \supseteq \llbracket e \rrbracket \cup \llbracket e' \rrbracket$,
\item the transfer relation $\transfer$ has to be total, that is $\forall e \in E: \exists e' \in E: e \transfer e'$, and
\item the transfer relation has to be precise or over-approximating. That means the union of all concrete states represented by all possible abstract successors of an abstract state $e$ and a program statement $g$ have to be the same or more than the union of all concrete successors of statement $g$ and all concrete states represented by $e$.
This can be formally expressed as $\forall e \in E, g \in G: \bigcup_{e \gtransfer e'} \llbracket e' \rrbracket\ \supseteq \bigcup_{c \in \llbracket e \rrbracket} \{ c' |\ c \overset{g}{\rightarrow} c' \}$
\end{enumerate}
Customization of program analysis usually means to choose one or more abstract interpreters, that is the abstract domains, transfer functions and widening operators to use.\cite{Beyer2007}

Configurable software verification tries to bridge the gap of precision finding of model checking and the efficiency focus of program analysis to allow for arbitrary algorithms between these two extremes by providing the possibility to control the precision and efficiency of the algorithm by choosing all of the following:
\begin{enumerate}[label=\alph*)]
\item one or more abstract interpretations, that is the abstract domains to work in and the transfer functions that describe the possible transfers between abstract states,
\item a merge operator which controls when two nodes of the reachability tree are merged, i.e. when two abstract states are merged, and
\item a stop operator that controls when the exploration of a path is stopped, i.e. when a state is already covered by the existing reached states. This is also called termination check.
\end{enumerate}
These elements are encapsulated in a \emph{configurable program analysis} (CPA) \cite{Beyer2007} , which is used by the CPA algorithm.

\subsubsection{Configurable program analysis definition}
A CPA $\cpa = (D, \transfer, \cpaMerge, \cpaStop)$ consists of an abstract domain $D$, a transfer relation $\transfer$, both defined as above, a merge operator $\cpaMerge : E \times E \rightarrow E$ and a stop operator $\cpaStop : E \times 2^E \rightarrow \booleanset$.

The merge operator weakens the information of the second given state based on the first state. The result of $\cpaMerge(e, e')$ can be anywhere between $e'$ and $\top$.
Two characteristic merge operators are \[\cpaMerge^{sep}(e, e') = e'\] and \[\cpaMerge^{join}(e, e') = e \join e'.\]
\begin{algorithm}[t]
\caption{$CPA(\cpa, e_0)$}
\label{alg:CPA}
\begin{algorithmic}[1]

\Input a CPA $\cpa = (D, \transfer, \cpaMerge, \cpaStop)$ 
	    and an initial abstract state $e_0 \in E$ with $E$ being the set of elements of $D$
\Output the set of abstract states reachable from $e_0$
\Variables \reachedSet\ and \waitlistSet , both sets of elements of $E$
\State $\reachedSet \assign \{e_0\}$
\State $\waitlistSet \assign \{e_0\}$
\While{$\waitlistSet \neq \varnothing$}
	\State choose $e$ from \waitlistSet \State remove $e$ from \waitlistSet
	\ForAll{$e'$ with $e \transfer e'$}
		\If{$\isTargetState{e'}$} \label{alg:cpa:isTarget}
			\Return $\reachedSet \cup \{ e' \}$
		\EndIf
		\ForAll{$e'' \in \reachedSet$} \label{alg:cpa:mergeStart}
			\State $e_{new} \assign \cpaMerge(e', e'')$ \Comment Combine with existing abstract state
			\If{$e_{new} \neq e''$}
				\State $\waitlistSet \assign (\waitlistSet \cup \{ e_{new} \}) \setminus \{ e'' \}$
				\State $\reachedSet \assign (\reachedSet \cup \{ e_{new} \}) \setminus \{ e'' \}$
			\EndIf
		\EndFor \label{alg:cpa:mergeStop}
		\If{$\neg \cpaStop(e', \reachedSet)$} \label{alg:cpa:stopCheck}
			\State $\waitlistSet \assign \waitlistSet \cup \{e'\}$
			\State $\reachedSet \assign \reachedSet \cup \{e'\}$
		\EndIf
	\EndFor
\EndWhile\\ 
\Return \reachedSet
\end{algorithmic}
\end{algorithm}

The stop operator checks if the given abstract state is covered by the set of abstract states given as second parameter.
$\cpaStop(e, R) = true$ always has to imply $\llbracket e \rrbracket \subseteq \bigcup_{e' \in R} \llbracket e' \rrbracket$ to ensure soundness.
Two characteristic stop operators are \[\cpaStop^{sep}(e, R) = \exists e' \in R : e \lesserEqual e'\] and \[\cpaStop^{join}(e, R) = e \lesserEqual \bigjoin\limits_{e' \in R} e'.\]
For $\cpaStop^{join}$, the abstract domain has to be a powerset domain, that means $e \lesserEqual e' \Rightarrow e \supseteq e'$ for abstract states $e, e'$.

The CPA algorithm \cite{Beyer2007} described in Algorithm \ref{alg:CPA} uses an arbitrary CPA of this form to solve the reachability problem.
We adjusted the algorithm from \cite{Beyer2007}\ to better fit a later introduced, more sophisticated version. The behaviour of the algorithm stays exactly the same, though.
Given a CPA $\cpa$ and an initial abstract state $e_0$ to start its computation at, the algorithm computes the set \reachedSet\ of reachable abstract states.
As long as the set of abstract states that still have to be processed (\waitlistSet) is not empty, an abstract state $e \in \waitlistSet$ is removed from the waitlist
and each possible abstract successor $e'$ is examined:

First, it is checked whether $e'$ represents any concrete state that violates a property. This is done by $\isTargetStateFunc : E \rightarrow \booleanset$ in Line \ref{alg:cpa:isTarget}, whose behaviour can be defined arbitrarily.
In classic reachability computation, the complete reachable set would be computed first.
If we did this (by defining $\isTargetState{e} = false$ for all $e$),
the target region $\targetRegion \subseteq C$ would be reachable if any of its concrete states were represented by any abstract state computed as reachable by the CPA algorithm:
\[\bigcup_{e \in CPA(\cpa, e_0)} \llbracket e \rrbracket\ \cap\ \targetRegion \neq \varnothing .\]

As next step of the examination of $e'$, each already reached abstract state $e'' \in \reachedSet$ is individually merged with the new state $e'$ and, if the merge weakened $e''$, it is replaced with the weakened state in \reachedSet\ and \waitlistSet\ (Lines \ref{alg:cpa:mergeStart} - \ref{alg:cpa:mergeStop}).
Next, the termination check $\cpaStop(e', \reachedSet)$ checks whether the new abstract successor $e'$ is already covered by the current reached set.
If it is not, it is added to \waitlistSet\ and \reachedSet.
After this it is continued with the next element in the waitlist.
If the waitlist is empty, there are no more reachable states and the reached set is returned.

\subsection{Basic definition of CPAs used in this paper}
A definition of all CPAs important to this paper follows.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\CompositeCPA}
It is often useful, in our case even necessary, to combine multiple CPAs to use their individual strengths and mitigate their weaknesses.
A composition of multiple CPAs can be expressed as a \compositeCPA\ \cite{BeyerBook}\ $\compCPA = (\cpa_1, ..., \cpa_i, \transfer_\times, \cpaMerge_\times, \cpaStop_\times)$.
It consists of:
\begin{enumerate}[leftmargin=*, label=\arabic*.]

\item An arbitrary number $i \geq 2$ of CPAs $\cpa_1$ to $\cpa_i$. All CPAs have to share the same set of concrete states $C$, but can differ in any other way.
\item \label{it:compTransfer} A composite transfer relation $\transfer_\times \subseteq (E_1 \times ... \times E_i) \times G \times (E_1 \times ... \times E_i)$.
\item \label{it:compMerge} A composite merge operator $\cpaMerge_\times : (E_1 \times ... \times E_i) \times (E_1 \times ... \times E_i) \rightarrow (E_1 \times ... \times E_i)$.
\item \label{it:compStop} A composite termination check $\cpaStop_\times : (E_1 \times ... \times E_i) \times 2^{E_1 \times ... \times E_i} \rightarrow \booleanset$.
\end{enumerate}
The three composite operators \ref{it:compTransfer} - \ref{it:compStop} use the corresponding operators of the contained CPAs $\cpa_1$ to $\cpa_i$ as well as multiple \emph{strenghtening operators} $\strengthen_j$ and \emph{compare relations} $\compare_j$. They only alter lattice elements through these components.

A strengthening operator $\strengthen : E_k \times E_l \rightarrow E_k$ with $1 \leq k, l \leq i$ and $k \neq l$ computes a stronger abstract state of the type $E_k$ by using the information of an abstract state of the type $E_l$. It has to meet the requirement $\strengthen(e, e') \lesserEqual e$.
The use of strengthening operators in the transfer relation $\transfer_\times$ allows the use of a transfer relation that is stronger than the simple combination of the transfer relations of $\cpa_1$ to $\cpa_i$.

A compare relation $\compare\ \subseteq E_k \times E_l$ allows the comparison of two abstract states of different types.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\LocationCPA}
The \locationCPA\ \cite{BeyerBook} $\locCPA = (D_\locCPA, \transfer_\locCPA, \cpaMerge^{sep}, \cpaStop^{sep})$ is a CPA that analyses the syntactical reachability of program locations.
It does not consider any semantics and is mostly used to track the program location for other CPAs by using a \compositeCPA.
This allows for simpler CPAs since they do not have to care about location tracking individually.
The \locationCPA\ contains:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item The abstract domain $D_\locCPA = (C, \loclattice, \concretization)$. It consists of the set  $C$ of possible concrete states, the semi-lattice $\loclattice$ and the concretization function $\concretization$.
	$\loclattice = (L \cup \{\top\}, \top_\locCPA, \bot, \lesserEqual, \join)$ is defined by its less-or-equal operator $\lesserEqual$, which has the following properties:
	$l \lesserEqual \top_\locCPA$, $l \neq l' \Rightarrow l \nlesserEqual l'$ and $\bot \lesserEqual l$ for all $l, l' \in L$
	(this implies $\top_\locCPA \join l = \top_\locCPA$ and $l \join l' = \top_\locCPA$ for all $l, l' \in L$ with $l \neq l'$) A semi-lattice with 	these properties is also called \emph{flat semi-lattice}.
	The concretization function is defined as $\llbracket \top_\locCPA \rrbracket = C$, $\llbracket l \rrbracket = \{ c \in C |\ c(pc) = l\}$ for all $l \in L$.
\item The transfer relation $\transfer_\locCPA$, which has the transfer $l \gtransfer_\locCPA l'$ if $g = (l, op, l')$ for any operation $op$
	and the transfer $\top_\locCPA \gtransfer_\locCPA \top_\locCPA$ for all $g \in G$.
\item The already mentioned merge operator $\cpaMerge^{sep}$, defined as $\cpaMerge^{sep}(l, l') = l'$ for all $l, l' \in \loclattice$ and
\item the already mentioned termination check $\cpaStop^{sep}$, defined as $\cpaStop^{sep}(l, R) = \exists l' \in R : l \lesserEqual l'$.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\PredicateCPA}
The \predicateCPA\ \cite{BeyerBook} uses predicate abstraction \cite{Ball2001} to compute abstract states from a formula $\phi$ and a set $\pi$ of predicates.
Two different kinds of predicate abstraction exist:
The cartesian predicate abstraction $(\phi)^{\pi}_C$ is the strongest conjunction of predicates from $\pi$ that is implied by $\phi$.
The boolean predicate abstraction $(\phi)^{\pi}_B$ is the strongest boolean combination of predicates from $\pi$ that is implied by $\phi$.
In this work, we will only look at cartesian predicate abstraction because of its greater simplicity.
For a set $r \subseteq \pi$, $\varphi_r$ denotes the conjunction of all predicates in $r$, with $\varphi_{\{\}} = true$.

The \predicateCPA\ $\predCPA = (D_\predCPA, \transfer_\predCPA, \cpaMerge^{sep}, \cpaStop^{sep})$ consists of:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item The abstract domain
	$D_\predCPA = (C, \predicatelattice, \concretization)$ with concrete states $C$, the semi-lattice $\predicatelattice$ and the concretization function $\concretization$.
	The semi-lattice is defined by $\predicatelattice = (2^{\pi}, \top_\predCPA, \bot, \lesserEqual, \join)$. Its abstract states are subsets of the precision $\pi$.
	An abstract state can be interpreted as the conjunction of all its formulas. $\top_\predCPA = \varnothing$ is an abstract state without any constraints (\emph{true}) and represents all possible concrete states.
	The bottom element $\bot = \{false\}$ represents no concrete state. A state $r$ is less or equal another state $r'$, if $r$ contains all predicates of $r'$, formally $r \lesserEqual r'$ if $r \supseteq r'$.
	The join of two states $r, r'$ is defined by $r \join r' = r \cap r'$.

	The concretization function $\concretization$ is defined by $\llbracket r \rrbracket = \{ c \in C |\ c \satisfies \varphi_r\}$

\item The transfer relation $\transfer_\predCPA$ has the transfer $r \gtransfer_\predCPA r'$ if $\strongestPost(\varphi_r, g)$ is satisfiable
	and $r'$ is the largest set of predicates so that $\varphi_r \Rightarrow \weakestPre(p, g)$ for each $p \in r'$.
	The operations $\strongestPost(\varphi, g)$ and $\weakestPre(\varphi, g)$ describe the strongest post-condition and the weakest pre-condition for a formula $\varphi$ and an operation $g$.
	They are defined such that
	\[\llbracket \strongestPost(\varphi, g) \rrbracket = \{c' \in C |\ \exists c \in C : c \gtransfer c' \logicAnd c \satisfies \varphi \}\] and
	\[\llbracket \weakestPre(\varphi, g) \rrbracket = \{c \in C |\ \exists c' \in C : c \gtransfer c' \logicAnd c' \satisfies \varphi \}.\]
\item The already mentioned merge operator $\cpaMerge^{sep}$, defined as $\cpaMerge^{sep}(r, r') = r'$ for all $r, r' \in \predicatelattice$ and
\item the already mentioned termination check $\cpaStop^{sep}$, defined as $\cpaStop^{sep}(r, R) = \exists r' \in R : r \lesserEqual r'$.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\ValueAnalysisCPA}\label{sec:valueAnalysis}
The \valueAnalysisCPA\ \cite{Beyer2013} \cite{Beyer2015} tracks integer values for all program variables explicitly.
It does so by using \emph{abstract variable assignments} \cite{Beyer2013}. An abstract variable assignment $v: X \partialFunc \integerset \cup \{\bot\}$ is a partial function that maps program variables $x \in X$ to integer values - if their assignment is known - or to $\bot$, if no possible value assignment exists.
An abstract variable assignment $v$ is \emph{contradicting} if $v(x) = \bot$ for any $x \in \defRange(v)$.
For two abstract variable assignments $v$ and $v'$, $v$ is \emph{implied} by $v'$, that is $v' \Rightarrow v$, if $v'$ is contradicting or if $\defRange(v') \subseteq \defRange(v)$ and for each variable $x \in \defRange(v) \cap \defRange(v') : v(x) = v'(x)$.
The \emph{conjunction} $v \logicAnd v'$ is defined as
\[(v \logicAnd v')(x) = \begin{dcases}
	\bot & \text{ if } x \in \defRange(v) \cap \defRange(v') \text{ and } v(x) \neq v'(x)\\
	v(x) & \text{ if } x \in \defRange(v)\\
	v'(x) & \text{ if } x \in \defRange(v')
\end{dcases}\]

We define the \emph{definition range} of a partial function $f$ as $\defRange(f) = \{ x |\ \exists y : (x, y) \in f \}$ and
the \emph{restriction} of a partial function $f$ to a new definition range $Y$ as $f_\restrictedTo{Y} = f \cap ( Y \times (\valueset \cup \{ \bot \}))$.

The \valueAnalysisCPA\ $\valCPA = (D_\valCPA, \transfer_\valCPA, \cpaMerge^{sep}, \cpaStop^{sep})$ consists of the following components:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item The abstract domain $D_\valCPA = (C, \vallattice, \concretization)$ contains the set $C$ of possible concrete states, the semi-lattice $\vallattice$ and the concretization function $\concretization$.
	The semi-lattice $\vallattice = (\valAssignment, \top_\valCPA, \bot, \lesserEqual, \join)$ consists of the set $\valAssignment = X \partialFunc \valueset$ of abstract variable assignments,
	with $X$ being the set of program variables and $\valueset = \integerset \cup \{ \bot_\valueset \}$ the set of integer values and the bottom element.
	The top element $\top_\valCPA$ of the abstract domain is defined as $\top_\valCPA = \varnothing$. It represents an unknown assignment for all program variables.
	The bottom element $\bot$ is defined as $\bot(x) = \bot_\valueset$ for all $x \in X$.
	It represents an impossible variable assignment, that is a state that cannot be reached in the program execution.
	The less-or-equal operator $\lesserEqual\ \subseteq \valAssignment \times \valAssignment$ defines $v \lesserEqual v'$ if $\defRange(v') \subseteq \defRange(v)$ and for all $x \in \defRange(v'): v(x) = v'(x)$ or $v(x) = \bot_\valueset$.
	This means that a state $v$ is less or equal a state $v'$ if $v$ contains all variable assignments of $v'$ or restricts them even further.

	The join operator $\join$ defines the least upper bound of two abstract variable assignments, but is never used in our configuration.
	
	The concretization function $\concretization$ assigns to each abstract state $v$ the concrete states it represents, $\llbracket v \rrbracket = \{ c \in C |\ c(x) = v(x) \text{ for all } x \in \defRange(v)\}$.
	If an abstract state $v$ contains an impossible variable assignment, that is $v(x) = \bot_\valueset$ for any $x \in \defRange(v)$, then it represents no concrete state: $\llbracket v \rrbracket = \varnothing$.
\item The transfer relation $\transfer_\valCPA$ has the transfer $v \gtransfer_\valCPA v'$ if one of the following is true:
	\begin{enumerate}[label=\alph*)]
	\item $g = (\cdot, \assume(p), \cdot)$ and for all $x \in \defRange(v')$:
		\[ v'(x) = \begin{dcases}
			\bot_\valueset & \text{ if } \exists y \in X : v(y) = \bot_\valueset \text{ or } p_\using{v} \text{ unsatisfiable}\\
			c & \text{ if $c$ is the only satisfying assignment of $p_\using{v}$ for $x$}\\
			v(x) & \text{ if none of the above and } x \in \defRange(v)
		\end{dcases}\]
		$p_\using{v}$ is the interpretation of a predicate $p$ using the known variable assignments of $v$, that is
		$p_\using{v} = p \logicAnd \biglogicAnd\limits_{x \in \defRange(v), v(x) \in \integerset}  x = v(x) \logicAnd \neg \exists x \in \defRange(v) : v(x) = \bot_\valueset$.
	\item $g = (\cdot, w \assign exp, \cdot)$ and
		\[ v'(x) = \begin{dcases}
			exp_\using{v} & \text{ if } x = w \text{ and } exp_\using{v} \neq \top_\valueset\\
			v(x) & \text{ if } x \neq w \text{ and } x \in \defRange(v)\\
		\end{dcases}\]
		$exp_\using{v}$ denotes the interpretation of an expression $exp$ using the values of abstract variable assignment $v$, that is
		\[exp_\using{v} = \begin{dcases}
			\bot_\valueset & \text{ if } \exists y : v(y) = \bot_\valueset\\
			\top_\valueset  & \parbox[t]{.6\textwidth}{if $y \not\in \defRange(v)$ for some $y \in X$ that occurs in $exp$}\\
			c & \parbox[t]{.6\textwidth}{ otherwise, where expression $exp$ is evaluated to $c$ after replacing each occurrence of variable $x \in \defRange(v)$ in $exp$ with $v(x)$}
		\end{dcases}\]
		with $\top_\valueset$ denoting an unknown value.
	\end{enumerate}
\item The previously mentioned merge operator $\cpaMerge^{sep}$. That means that no merge is performed. This is the only aspect in which \constantpropagationCPA\ \cite{BeyerBook} and \valueAnalysisCPA\ differ.
\item The previously mentioned termination check $\cpaStop^{sep}$, which checks every abstract state individually.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\SymbolicValueAnalysisCPA}
The \symbolicValueAnalysisCPA\ \cite{Lemberger2015} is an extension to the \valueAnalysisCPA. It introduces \emph{symbolic values} to handle non-deterministic values and expressions of unknown value.

The \symbolicValueAnalysisCPA\ $\symValCPA = (D_\symValCPA, \transfer_\symValCPA, \cpaMerge^{sep}, \cpaStop^{sep})$ consists of:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item The abstract domain $D_\symValCPA = (C, \symvallattice, \concretization)$ with the set $C$ of concrete states,
	the semi-lattice $\symvallattice$ and
	the concretization function $\concretization$.
	The semi-lattice $\symvallattice = (\symvalAssignment, \top_\symValCPA, \bot, \lesserEqual, \join)$ is defined by
	the set of abstract symbolic value assignments $\symvalAssignment = X \partialFunc \symvalset$ mapping program variables in its definition range to values of
	$\symvalset = \integerset \cup \symValues \cup \{ \bot_\valueset \}$.
	The value range of an abstract variable assignment of the type $\symvalAssignment$ consists of the set $\integerset$ of concrete integer values,
	the set $\symValues$ of symbolic values and the bottom element $\bot_\valueset$, which represents an impossible variable assignment.
	$\symValues = \symIds \cup \symExpressions$ consists of \emph{symbolic identifiers} $\symIds$ and \emph{symbolic expressions} $\symExpressions$.
	Each expression that contains at least one symbolic identifier is a symbolic expression.
	The definition range of an abstract variable assignment of $\symvalAssignment$ consists of all program variables whose value is known as either a concrete value (of $\integerset$),
	a symbolic value (of $\symValues$) or as invalid ($\bot_\valueset$).
	The top element $\top_\symValCPA = \varnothing$ represents no known assignment.

	For two abstract states $v, v' \in \symvalAssignment$, $v \lesserEqual v'$, if all of the following conditions hold:
	(a) $v'$ must only contain value assignments of $v$, that is $\defRange(v') \subseteq \defRange(v)$,
	(b) for every concrete or invalid assignment of $v$, $v'$ must contain the same or a weaker one, that means the same value or a concrete value for $\bot_\valueset$, formally put
	\[\forall x \in \defRange(v') : v(x) \in \integerset \cup \{\bot_\valueset\} \Rightarrow v'(x) = v(x) \logicOr v(x) = \bot_\valueset\]
	(c) A bijective function $\aliasFunc : \symIds \rightarrow \symIds$ exists that maps each symbolic identifier of $\symIds$ to another symbolic identifier, so that
	$\forall x \in \defRange(v') : v'(x) \in \symValues \Rightarrow v(x)$ results from $v'(x)$ by replacing all $i \in \symIds$ occurring in $v'(x)$ with $\aliasFunc(i)$.
	It can be thought of simpler or more precise less-or-equal operators. Such operators will be examined later.
	Here, we use this operator (with some fixes to its origin) simply because it was used in our previous work \cite{Lemberger2015}.

	Note that with this operator $v' \lesserEqual v \Rightarrow \llbracket v' \rrbracket \subseteq \llbracket v \rrbracket$, but in general $\llbracket v' \rrbracket \subseteq \llbracket v \rrbracket \not\Rightarrow v' \lesserEqual v$.

	The join $\join : \symvalAssignment \times \symvalAssignment$ is defined as
	\[(v \join v')(x) = \begin{dcases}
		v(x) & \text{ if } v(x) = v'(x)\\
		\bot_\valueset & \text{ if } v(x) = \bot_\valueset \text{ or } v'(x) = \bot_\valueset
	\end{dcases}\]
	for all $x \in \defRange(v \join v')$.

\item The transfer relation $\transfer_\symValCPA$ contains the transfer $v \gtransfer_\symValCPA v''$, if one of the following conditions is true:
	\begin{enumerate}[label = \alph*)]
		\item $g = (\cdot, \assume(p), \cdot)$, $p_\using{v}$ is satisfiable and for all $x \in \defRange(v'')$
			\[ v''(x) = \begin{dcases}
				c & \parbox[t]{.6\textwidth}{ if $c$ is the only satisfying assignment for $p_\using{v}$ and $x \not\in \defRange(v)$}\\
				y & \parbox[t]{.6\textwidth}{ if $x \not\in \defRange(v)$ and $x$  appears in $p$. $y \in \symIds$ is a new symbolic values that has not been used in any other state before}\\
				v(x) & \text{ if none of the above and } x \in \defRange(v)
			\end{dcases}\]
			$p_\using{v}$ performs an over-approximation in this case, as variables with a symbolic assignment are not considered.
			Reminder: \[p_\using{v} = p \logicAnd \biglogicAnd\limits_{x \in \defRange(v), v(x) \in \integerset}  x = v(x) \logicAnd \neg \exists x \in \defRange(v) : v(x) = \bot_\valueset\]

		\item $g = (\cdot, w \assign exp, \cdot)$ and
			\[ v''(x) = \begin{dcases}
				exp_\using{v'} & \text{ if } x = w\\
				v'(x) & \text{ if } x \in \defRange(v) \text{ and } x \neq w
			\end{dcases}\]
			with
			\[v'(x) = \begin{dcases}
				y & \parbox[t]{.6\textwidth}{if $x \not \in \defRange(v)$ and $x$ appears in $exp$. $y \in \symIds$ is a new symbolic identifier that has not been used in any other state before}\\
				v(x) & \text{ if } x \in \defRange(v)
			\end{dcases}\]
			and $exp_\using{v'}$ defined as before. If any symbolic value occurs in $exp$ after replacing all occurences $x \in X$ in $exp$ with $v'(x)$,
			the expression is only partially evaluated. In this case $exp_\using{v'} \in \symValues$.
		\item $v'' = \top_\symValCPA$.
	\end{enumerate}

\item The use of $\cpaMerge^{sep}$ means that no merge of abstract states is performed.
\item The termination check $\cpaStop^{sep}$ already mentioned considers every state independently when checking for coverage.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\ConstraintsCPA}

The \constraintsCPA\ tracks constraints (i.e. boolean formulas) on symbolic identifiers created by assume edges.
For this, it relies on the values provided by the \symbolicValueAnalysisCPA\ to partially evaluate assume edges and create constraints out of them.
The \constraintsCPA\ $\constrCPA = (D_\constrCPA, \transfer_\constrCPA, \cpaMerge^{sep}, \cpaMerge^{sep})$ is defined by:
\begin{enumerate}[leftmargin=*,label=\arabic*.]
\item The abstract domain $D_\constrCPA = (C, \constraintslattice, \concretization)$,
	which consists of concrete states $C$, the semi-lattice $\constraintslattice$ and the concretization function $\concretization$.
	
	The abstract states described by $\constraintslattice = (2^\constraintsset, \top_\constrCPA, \bot, \lesserEqual, \join)$ are subsets of the set $\constraintsset$ of all possible boolean expressions over the possible values of the \symbolicValueAnalysisCPA, $\symvalset$, and program variables, $X$. This includes concrete and symbolic values. An abstract state $a \subseteq \constraintsset$ can be interpreted as the conjunction of all its constraints, where each symbolic identifier $i \in \symIds$ is handled as a variable.
	The top element $\top_\constrCPA = \varnothing$ contains no constraints (it represents $true$). The bottom element $\bot$ represents a program state that can never be reached. It represents $false$.
	$\lesserEqual$ is defined in the following way: For two given states $a, a' \subseteq \constraintsset$, $a$ is less or equal $a'$, that is $a \lesserEqual a'$, if a bijective function $\aliasFunc : \symIds \rightarrow \symIds$ exists, so that $a'' \subseteq a$ with $a''$ resulting from $a'$ by replacing all symbolic identifiers $i \in \symIds$ occurring in the constraints of $a'$ with $\aliasFunc(i)$.
	The join $\join$ computes the least upper bound of two abstract states, but is never used.

	The concretization function $\concretization$ maps an abstract state to all concrete states that satisfy its constraints:
	\[ \llbracket a \rrbracket = \{ c \in C |\ c \satisfies \varphi_a \} \]
	with $\varphi_a$ denoting the conjunction of all predicates in $a$, $\varphi_a = \biglogicAnd\limits_{p \in a} p$.

\item The transfer relation $\transfer_\constrCPA$ contains the transfer $a \gtransfer_\constrCPA a'$ if one of the following is true:
	\begin{enumerate}[label=\alph*)]
		\item $g = (\cdot, \assume(p), \cdot)$, $a' = a \cup p$ and
			$a$ does not contain any variable $x \in X$.
			We just add the condition of the assume as a new constraint to the abstract state.
			Since $a$ may not contain any program variables we enforce that
			variables must always be replaced by concrete or symbolic values through immediate strengthening at the same edge. Or,
		\item $g = (\cdot, w \assign e, \cdot)$ and $a' = a$. \ConstraintsCPA\ only cares about assume edges.
	\end{enumerate}
	
\item The merge operator $merge^{sep}$. No merge is performed when the control flow meets. We will introduce an alternative merge operator later on.
\item The termination check $stop^{sep}(e, R) = \exists e' \in R: e \lesserEqual e'$ considers every reached abstract state individually.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\SymbolicExecutionCPA : Composition of Location CPA, Symbolic Value Analysis CPA and Constraints CPA}
The \symbolicExecutionCPA\ \cite{Lemberger2015}\ is the composition of \locationCPA, \symbolicValueAnalysisCPA\ and \constraintsCPA.
Besides connecting the \locationCPA\ to the other CPAs so abstract states can be mapped to a program location, its most important task is the definition of a strengthening operator that creates new constraints in the \constraintsCPA\ and checks their satisfiability.

The \symbolicExecutionCPA\ $\symExCPA = (\locCPA, \symValCPA, \constrCPA, \transfer_\symExCPA, \cpaMerge_\symExCPA, \cpaStop_\symExCPA)$ is a \compositeCPA\ that consists of:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item The three CPAs $\locCPA$, $\symValCPA$ and $\constrCPA$ defined above.
\item The transfer relation $\transfer_\symExCPA : (D_\locCPA \times D_\symValCPA \times D_\constrCPA) \rightarrow (D_\locCPA \times D_\symValCPA \times D_\constrCPA)$.
	It contains the transfer $(l, v, a) \gtransfer_\symExCPA (l', v', a')$ if $l \gtransfer_\locCPA l'$, $v \gtransfer_\symValCPA v'$ and if one of the following conditions is true:
	\begin{enumerate}[label=\alph*)]
		\item $g = (\cdot, \assume(p), \cdot)$ and $\strengthenOp{\constrCPA}{\symValCPA}(a'', v') = a'$ is defined, with $a \gtransfer_\constrCPA a''$.

		\item $g = (\cdot, w \assign e, \cdot)$ and $a = a'$.
	\end{enumerate}
	It uses the strengthening operator $\strengthenOp{\constrCPA}{\symValCPA} : \constraintslattice \times \symvallattice \rightarrow \constraintslattice$ that strengthens an abstract state of the \constraintsCPA\ by using an abstract state of the \symbolicValueAnalysisCPA.
	$\strengthenOp{\constrCPA}{\symValCPA}(a'', v) = a'$ is defined if both of the following conditions are true:
	\begin{enumerate}[label=\alph*)]
		\item $a'$ results from $a''$ by replacing all program variables $x$ occurring in the constraints of $a''$ by their abstract value assignment $v(x)$.
			$v(x)$ can be a concrete or symbolic value as well as $\bot_\valueset$.
		\item  $\varphi_{a'}$ is satisfiable.
	\end{enumerate}
\item The merge operator
	$\cpaMerge_\symExCPA : (\loclattice \times \symvallattice \times \constraintslattice) \times (\loclattice \times \symvallattice \times \constraintslattice) \rightarrow (\loclattice \times \symvallattice \times \constraintslattice)$ uses the merge operators of each CPA on the corresponding abstract states individually.
\item The stop operator $\cpaStop_\symExCPA : (\loclattice \times \symvallattice \times \constraintslattice) \times 2^{\loclattice \times \symvallattice \times \constraintslattice}$
	uses the stop operators of each CPA on the corresponding abstract state and reached set individually.
\end{enumerate}