\section{General Overview of configurable program analysis}
\begin{figure}
\lstset{numbers=left}
\begin{subfigure}[b]{.48\textwidth}
\lstinputlisting[language=C]{exampleProgram.c}
\end{subfigure}%
\hfill
\begin{subfigure}[b]{.48\textwidth}
\begin{tikzpicture}[->,>=stealth, mynode/.style={circle, draw, minimum size=0.5cm}, every node/.style={font=\small}]

  \node[mynode] (1) {4};
  \node[mynode] (2) [below = 0.6cm of 1]{7};
  \node[mynode] (3) [below left = 1.2cm of 2]{11};
  \node[mynode] (4) [below right = 1.2cm of 2]{8};
  \node[mynode] (5) [below = 0.5cm of 3]{12};
  \node[mynode] (6) [below = 0.5cm of 4]{10};
  \node[mynode] (7) [below right = 1.2cm of 5]{14};
  \node[mynode] (8) [below left = 1cm of 7]{17};
  \node[mynode] (9) [below right = 1cm of 7]{16};

  \path
    (1) edge node [right] {\textbf{a $\assign$ \_\_VERIFIER\_nondet\_int()}} (2)
    (2) edge node [left, pos=0.5] {$\mathbf{[!(a \geq 0)]}$} (3)
    (2) edge node [right, pos=0.5] {$\mathbf{[a \geq 0]}$} (4)
    (3) edge node [left] {\textbf{b $\assign$ a + 1}} (5)
    (4) edge node [right] {\textbf{b $\assign$ a}} (6)
    (5) edge (7)
    (6) edge (7)
    (7) edge node [left] {$\mathbf{[!(b < a)]}$} (8)
    (7) edge node [right] {$\mathbf{[b < a]}$} (9)
  ;
\end{tikzpicture}
\end{subfigure}
\caption{An example CFA.}
\label{fig:exCFA}
\end{figure}

For the sake of simplicity, all theoretical concepts are based on a fictional programming language that only consists of variable assignments (e.g. $x \assign 5$ or $y \assign x$) and assumptions (e.g. $[x > 5]$ or $[y < x]$).
All values are integers of arbitrary magnitude.
The implementation of our presented concepts is performed in \cpaChecker\, a verification tool for C programs, though.

We represent a program by a \emph{control flow automaton} (CFA) \cite{BeyerBook}\cite{Beyer2012}.
A CFA $A = (L, l_0, G)$ is a directed graph whose nodes $L$ represent the program locations of the program.
The initial node $l_0 \in L$ represents the program entry.
An edge $g \in G \subseteq L \times Ops \times L$ exists between two nodes if a program statement exists that transfers control between the program locations represented by the nodes.
Each edge is labeled with the operation that transfers the control.
If a node has no leaving edges it is a final node. Final nodes represent the program exit.
A CFA for the previously mentioned example program can be seen in Figure \ref{fig:exCFA}.
A \emph{path} $\sigma$ \cite{Beyer2015} is a sequence $\langle (op_1, l_1), ..., (op_n, l_n)$ of program locations and their corresponding operations.
A path $\sigma$ is a \emph{program path}, if $\sigma$ represents a syntactic walk through the CFA, that means for every $1 \leq i \leq n$ a CFA edge $g = (l_{i-1}, op_i, l_i)$ exists and $l_0$ is the initial program location.
Every path $\sigma = \langle (op_1, l_1), ..., (op_n, l_n) \rangle$ defines a \emph{constraint sequence} $\gamma_\sigma = \langle op_1, ..., op_n \rangle$.
The \emph{conjunction} of two constraint sequences $\gamma = \langle op_1, ..., op_n \rangle$ and $\gamma' = \langle op'_1, .., op'_n \rangle$ is defined as their concatenation,
that means $\gamma \logicAnd \gamma' = \langle op_1, ..., op_n, op'_1, ..., op'_n \rangle$.
The set $X$ is the set of all program variables occurring in a program.

\subsection{Concrete state definition}
A concrete state $c$ is a total function $c: X \cup \{pc\} \rightarrow \integerset$ that assigns a specific value of $\integerset$ to every program variable $x \in X$ and to the program counter $pc$. The program counter $pc$ represents the current location in the program.
The set of all concrete states of a program is $C$. A set $r \subseteq C$ is called a \emph{region}.
For the reachability problem the region of concrete states that violate a given specification is called the \emph{target region} $\targetRegion$.

\subsection{Abstract state definition}
\label{sec:abstractState}
An abstract domain \cite{Beyer2007} $D = (C, \semilattice, \concretization)$ consists of a set of possible concrete states $C$, a semi-lattice $\semilattice$ that describes the abstract states and their possible relation to each other and a concretization function $\concretization : \semilattice \rightarrow 2^C$ which maps each element of $\semilattice$ to a subset of $C$.

A semi-lattice $\semilattice = (E, \top, \bot, \lesserEqual, \join)$ consists of a set $E$ of elements, a top element $\top \in E$, a partial order $\lesserEqual\ \subseteq (E \times E)$
and the total function $\join : (E \times E) \rightarrow E$ called join operator. The elements $e \in E$ of an abstract domain are called \emph{abstract states}.

The basis of automatic software verification is the reachability problem: For a given specification it is derived whether a program state is reachable that violates this specification.
Traditionally, two major approaches exist, both working on a reachability tree: Model checking and program analysis, also called data flow analysis.
While model checking is mostly concerned with finding a program abstraction with a precision high enough to eliminate false alarms,
which in turn only allows it to handle small programs because of poor performance,
program analysis tries to reach high efficiency by looking at only a few chosen characteristics of a program. %\cite{Beyer2007}%cite here or below? out of lecture notes, so cite in some other way? 
It does so by using abstract states of a specific, chosen abstract domain to abstract from concrete program states.

Program analysis starts with an initial abstract state, usually $\top$, and uses a transfer relation to derive new abstract states from old abstract states and program statements.
Customization of program analysis usually means to choose one or more abstract interpreters, that is the abstract domains, transfer functions and widening operators to use.\cite{Beyer2007}

Configurable software verification tries to bridge the gap of precision finding of model checking and the efficiency focus of program analysis to allow for arbitrary algorithms between these two extremes by providing the possibility to control the precision and efficiency of the algorithm by choosing all of the following:
\begin{enumerate}[label=\alph*)]
\item one or more abstract interpretations, that is the abstract domains to work in and the transfer functions that describe the possible transfers between abstract states,
\item a precision type,
\item a merge operator which controls when two nodes of the reachability tree are merged, i.e. when two abstract states are merged,
\item a stop operator that controls when the exploration of a path is stopped, i.e. when a state is already covered by the existing reached states (this is also called termination check), and
\item a precision adjustment operator that can weaken or strengthen an abstract state based on a precision.
\end{enumerate}
These elements are encapsulated in a \emph{configurable program analysis} (CPA) \cite{Beyer2008}, which is used by the CPA algorithm.

\subsection{Configurable program analysis definition}
A CPA with dynamic precision adjustment $\cpa = (D, \Pi, \transfer, \cpaMerge, \cpaStop, \cpaPrec )$ consists of:

\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item
The abstract domain $D$, as described above. $E$ is the set of its semi-lattice's elements.
For soundness (i.e. if a property violation exists, it is always found) and progress of the program analysis, the following requirements have to be fulfilled:\cite{Beyer2007}\cite{Beyer2008}
\begin{enumerate}[label=\alph*)]

\item
the top element of abstract states has to represent all possible concrete states and the bottom element must represent none, formally put $\llbracket \top \rrbracket = C$ and $\llbracket \bot \rrbracket = \varnothing$,

\item
the join operator has to be precise or over-approximating. That means the join of two abstractes states always has to represent the same or more concrete states than the union of the concrete states both abstract states represent. This can be formally expressed as $\forall e, e' \in E: \llbracket e \join e' \rrbracket \supseteq \llbracket e \rrbracket \cup \llbracket e' \rrbracket$,

\item
$\forall e, e' \in E : e \lesserEqual e' \Rightarrow \llbracket e \rrbracket \subseteq \llbracket e' \rrbracket$
\end{enumerate}

\item
The precision type $\Pi$.

\item
The transfer relation $\transfer\ \subseteq (E \times G \times E \times \Pi)$. It assigns to each abstract state $e \in E$ possible abstract successors $e' \in E$ with a precision $\pi \in \Pi$.
For every program statement $g \in G$ we write $e \gtransfer (e', \pi)$ if $(e, g, e', \pi) \in \transfer$ and $e \transfer (e', \pi)$ if a program statement $g$ with $e \gtransfer (e', \pi)$ exists.

The transfer relation $\transfer$ has to be total, that is $\forall e \in E: \exists e' \in E: e \transfer e'$, and
it has to be precise or over-approximating. That means the union of all concrete states represented by all possible abstract successors of an abstract state $e$ and a program statement $g$ have to be the same or more than the union of all concrete successors of statement $g$ and all concrete states represented by $e$.
This can be formally expressed as $\forall e \in E, g \in G: \bigcup_{e \gtransfer e'} \llbracket e' \rrbracket\ \supseteq \bigcup_{c \in \llbracket e \rrbracket} \{ c' |\ c \overset{g}{\rightarrow} c' \}$

\item
The merge operator $\cpaMerge : E \times E \times \Pi \rightarrow E$, which weakens the information of the second given state based on the first state. It returns an abstract state of the given precision. The result of $\cpaMerge(e, e', \pi)$ can be anywhere between $e'$ and $\top$.
Two characteristic merge operators are \[\cpaMerge^{sep}(e, e', \pi) = e'\] and \[\cpaMerge^{join}(e, e', \pi) = e \join e'.\]

\item
The stop operator $\cpaStop : E \times 2^E \times \Pi \rightarrow \booleanset$, which checks if the given abstract state with the given precision is covered by the set of abstract states given as second parameter.
$\cpaStop(e, R, \pi) = true$ always has to imply $\llbracket e \rrbracket \subseteq \bigcup_{e' \in R} \llbracket e' \rrbracket$ to ensure soundness.
Two characteristic stop operators are \[\cpaStop^{sep}(e, R, \pi) = \exists e' \in R : e \lesserEqual e'\] and \[\cpaStop^{join}(e, R, \pi) = e \lesserEqual \bigjoin\limits_{e' \in R} e'.\]
For $\cpaStop^{join}$, the abstract domain has to be a powerset domain, that means $e \lesserEqual e' \Rightarrow e \supseteq e'$ for abstract states $e, e'$.

\item
The precision adjustment $\cpaPrec : E \times \Pi \times 2^{E \times \Pi} \rightarrow E \times \Pi$. It computes a new abstract state and precision for a given abstract state based on its precision and a set of abstract states with precision.
It can both strengthen and weaken an abstract state.
The following condition has to hold: $\forall e, \hat{e} \in E, \pi, \hat{\pi} \in \Pi, R \subseteq (E \times \Pi) : (\hat{e}, \hat{p}) = \cpaPrec(e, \pi, R) \Rightarrow \llbracket e \rrbracket \subseteq \llbracket \hat{e} \rrbracket$.

\end{enumerate} 

\begin{algorithm}[t]
\caption{$CPA(\cpa, e_0, \pi_0)$, adapted from \cite{Beyer2008}}
\label{alg:CPA}
\begin{algorithmic}[1]

\Input a CPA $\cpa = (D, \Pi, \transfer, \cpaMerge, \cpaStop, \cpaPrec)$,
	    an initial abstract state $e_0 \in E$ with $E$ being the set of elements of $D$,
	    and an initial precision $\pi_0 \in \Pi$.
\Output a set of abstract states reachable from $e_0$
\Variables \reachedSet\ and \waitlistSet , both subsets of $E \times \Pi$
\State $\reachedSet \assign \{ (e_0, \pi_0) \}$
\State $\waitlistSet \assign \{ (e_0, \pi_0) \}$
\While{$\waitlistSet \neq \varnothing$}
	\State choose $(e, \pi)$ from \waitlistSet
	\State remove $(e, \pi)$ from \waitlistSet
	\ForAll{$e'$ with $e \transfer (e', \pi)$}
		\State $(\hat{e}, \hat{\pi}) \assign \cpaPrec(e', \pi, \reachedSet)$ \Comment Precision adjustment \label{alg:cpaPlus:precAdj}
		\If{$\isTargetState{\hat{e}}$} \label{alg:cpa:isTarget}
			\State %empty state so that the return statement below is in a new line
			\Return $(\reachedSet \cup \{ (\hat{e}, \hat{\pi}) \},\ \waitlistSet)$
		\EndIf
		\ForAll{$(e'', \pi '') \in \reachedSet$}
			\State $e_{new} \assign \cpaMerge(\hat{e}, e'', \hat{\pi})$ \Comment Combine with existing state \label{alg:cpa:mergeStart}
			\If{$e_{new} \neq e''$} 
				\State $\waitlistSet \assign (\waitlistSet \cup \{ (e_{new}, \hat{\pi}) \}) \setminus \{ (e'',\pi '') \}$
				\State $\reachedSet \assign (\reachedSet \cup \{ (e_{new}, \hat{\pi}) \}) \setminus \{ (e'', \pi '') \}$
			\EndIf \label{alg:cpa:mergeStop}
		\EndFor
		\If{$\neg \cpaStop(\hat{e}, \{ e |\ (e, \cdot) \in \reachedSet \}, \hat{\pi})$}
			\State $\waitlistSet \assign \waitlistSet \cup \{ (\hat{e}, \hat{\pi}) \}$
			\State $\reachedSet \assign \reachedSet \cup \{ (\hat{e}, \hat{\pi}) \}$
		\EndIf
	\EndFor
\EndWhile
\State %empty state so that the return statement below is in a new line
\Return \reachedSet
\end{algorithmic}
\end{algorithm}

\subsection{CPA algorithm}
The CPA algorithm described in Algorithm \ref{alg:CPA} uses an arbitrary CPA of this form to solve the reachability problem.
Given a CPA $\cpa$, an initial abstract state $e_0$ to start its computation at and an initial precision $\pi_0$, the algorithm computes the set \reachedSet\ of reachable abstract states.
As long as the set of abstract states that still have to be processed (\waitlistSet) is not empty, an abstract state $e \in \waitlistSet$ is removed from the waitlist
and each possible abstract successor $e'$ and its precision $\pi$ is examined:

First, precision adjustment is performed on $e'$ based on $\pi$ and $\reachedSet$. This produces a new abstract state $\hat{e}$ and a new precision $\hat{\pi}$.

Next, it is checked whether the adjusted state $\hat{e}$ represents any concrete state that violates a property. This is done by $\isTargetStateFunc : E \rightarrow \booleanset$ in Line \ref{alg:cpa:isTarget}, whose behaviour can be defined arbitrarily.
In classic reachability computation, the complete reachable set would be computed first.

Next, each already reached abstract state $e'' \in \reachedSet$ is individually merged with the new state $\hat{e}$ with precision $\hat{\pi}$. If the merge weakened $e''$, it and its precision are replaced with the weakened state and the new precision $\hat{\pi}$ in \reachedSet\ and \waitlistSet\ (Lines \ref{alg:cpa:mergeStart} - \ref{alg:cpa:mergeStop}).
Next, the termination check checks whether the new abstract successor $\hat{e}$ is already covered by the current reached set.
If it is not, it is added to \waitlistSet\ and \reachedSet.
After this it is continued with the next element in the waitlist.
If the waitlist is empty, there are no more reachable states and the reached set is returned.

\section{Basic definition of CPAs used in this paper}
A definition of all CPAs important to this paper follows.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\CompositeCPA}
It is often useful to combine multiple CPAs to use their individual strengths and mitigate their weaknesses.
A composition of two CPAs \cite{Beyer2008} can be expressed as $(\cpa_1, \cpa_2, \Pi_\times, \transfer_\times, \cpaMerge_\times, \cpaStop_\times, \cpaPrec_\times)$.
We will extend this definition to allow the composition of an arbitrary number of CPAs.
It consists of:
\begin{enumerate}[leftmargin=*, label=\arabic*.]

\item Two CPAs $\cpa_1$ and $\cpa_2$. The CPAs have to share the same set of concrete states $C$, but can differ in any other way.
\item A composite set of precisions $\Pi_\times$.
\item \label{it:compTransfer} A composite transfer relation $\transfer_\times \subseteq (E_1 \times E_2) \times G \times (E_1 \times E_2) \times \Pi_\times$.
\item \label{it:compMerge} A composite merge operator $\cpaMerge_\times : (E_1 \times E_2) \times (E_1 \times E_2) \times \Pi_\times \rightarrow (E_1 \times E_2)$.
\item \label{it:compStop} A composite termination check $\cpaStop_\times : (E_1 \times E_2) \times 2^{E_1 \times E_2} \times \Pi_\times \rightarrow \booleanset$.
\item A composite precision adjustment \[\cpaPrec_\times : (E_1 \times E_2) \times \Pi_\times \times 2^{(E_1 \times E_2) \times \Pi_\times} \rightarrow (E_1 \times E_2) \times \Pi_\times.\]
\end{enumerate}
The three composite operators \ref{it:compTransfer} - \ref{it:compStop} use the corresponding operators of the contained CPAs $\cpa_1$ to $\cpa_i$ as well as multiple \emph{strenghtening operators} $\strengthen_j$ and \emph{compare relations} $\compare_j$. They only alter lattice elements through these components.

The strengthening operator $\strengthen : E_k \times E_l \rightarrow E_k$ computes a stronger abstract state of the type $E_k$ by using the information of an abstract state of the type $E_l$,
with $1 \leq k,l \leq i$ and $k \neq l$ for $i$ being the number of CPAs in the composition.
It has to meet the requirement $\strengthen(e, e') \lesserEqual e$.
The use of strengthening operators in the transfer relation $\transfer_\times$ allows the use of a transfer relation that is stronger than the simple combination of the transfer relations of $\cpa_1$ and $\cpa_2$.

A compare relation $\compare\ \subseteq E_k \times E_l$ allows the comparison of two abstract states of different types.

The composition of CPAs can be used to construct a \compositeCPA\ $\compCPA = (D_\times, \Pi_\times, \transfer_\times, \cpaMerge_\times, \cpaStop_\times, \cpaPrec_\times)$
with abstract domain $D_\times = D_1 \times D_2 = (C, \semilattice_\times, \concretization_\times)$
and semi-lattice $\semilattice_\times = \semilattice_1 \times \semilattice_2 = (E_1 \times E_2, (\top_1, \top_2), (\bot_1, \bot_2), \lesserEqual_\times, \join_\times)$.
The semi-lattice uses the less-or-equal operator $\lesserEqual_\times$ defined as $(e_1, e_2) \lesserEqual_\times (e'_1, e'_2)$ if $e_1 \lesserEqual_1 e'_1$ and $e_2 \lesserEqual_2 e'_2$
and the join operator defined as $(e_1, e_2) \join_\times (e'_1, e'_2) = (e_1 \join_1 e'_1, e_2 \join_2 e'_2)$.
The concretization function $\concretization_\times$ is defined as $\llbracket (e_1, e_2) \rrbracket_\times = \llbracket e_1 \rrbracket_1 \cap \llbracket e_2 \rrbracket_2$.

A special merge operator in this context is \[\mergeAgree : (E_1 \times E_2) \times (E_1 \times E_2) \times (\Pi_1 \times \Pi_2) \rightarrow (E_1 \times E_2)\]. It uses the merge operators of each CPA on the corresponding abstract states individually, if, after the merge, every component's state is less or equal the both given states. Otherwise it behaves like $\cpaMerge^{sep}$, i.e. no merge is performed.
\begin{align*}
&\mergeAgree(e_1, e_2, e'_1, e'_2, \pi_1, \pi_2) =\\
&\begin{dcases}
(\cpaMerge_1(e_1, e'_1, \pi_1), \cpaMerge_2(e_2, e'_2, \pi_2)) & \parbox{.4\textwidth}{if $\cpaMerge_1 (e_1, e'_1, \pi_1) \lesserEqual e_1, e'_1$ and $\cpaMerge_2(e_2, e'_2, \pi_2) \lesserEqual e_2, e'_2$}\\
(e'_1, e'_2) & \text{ otherwise}
\end{dcases}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\LocationCPA}
The \locationCPA\ \cite{BeyerBook} \cite{Beyer2008} $\locCPA = (D_\locCPA, \singletonPi, \transfer_\locCPA, \cpaMerge^{sep}, \cpaStop^{sep}, \singletonPrec)$ is a CPA that analyses the syntactical reachability of program locations.
It does not consider any semantics and is mostly used to track the program location for other CPAs by using a \compositeCPA.
This allows for simpler CPAs since they do not have to care about location tracking individually.
The \locationCPA\ contains:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item
The abstract domain $D_\locCPA = (C, \loclattice, \concretization)$. It consists of the set  $C$ of possible concrete states, the semi-lattice $\loclattice$ and the concretization function $\concretization$.
	$\loclattice = (L \cup \{\top\}, \top_\locCPA, \bot, \lesserEqual, \join)$ is defined by its less-or-equal operator $\lesserEqual$, which has the following properties:
	$l \lesserEqual \top_\locCPA$, $l \neq l' \Rightarrow l \nlesserEqual l'$ and $\bot \lesserEqual l$ for all $l, l' \in L$
	(this implies $\top_\locCPA \join l = \top_\locCPA$ and $l \join l' = \top_\locCPA$ for all $l, l' \in L$ with $l \neq l'$) A semi-lattice with 	these properties is also called \emph{flat semi-lattice}.
	The concretization function is defined as $\llbracket \top_\locCPA \rrbracket = C$, $\llbracket l \rrbracket = \{ c \in C |\ c(pc) = l\}$ for all $l \in L$.

\item
The set $\singletonPi = \{ \singletonPrecision$ of precisions that only contains a single precision. This means that all abstract states have the same precision all the time.

\item
The transfer relation $\transfer_\locCPA$, which has the transfer $l \gtransfer_\locCPA (l', \singletonPrecision)$ if $g = (l, op, l')$ for any operation $op$
	and the transfer $\top_\locCPA \gtransfer_\locCPA (\top_\locCPA, \singletonPrecision)$ for all $g \in G$.

\item
The already mentioned merge operator $\cpaMerge^{sep}$, defined as $\cpaMerge^{sep}(l, l', \pi) = l'$ for all $l, l' \in \loclattice$.

\item 
The already mentioned termination check $\cpaStop^{sep}$, defined as $\cpaStop^{sep}(l, R, \pi) = \exists l' \in R : l \lesserEqual l'$.

\item
The precision adjustment $\singletonPrec$ that does not change anything: $\singletonPrec(l, \pi, R) = (l, \pi)$.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\PredicateCPA}
A predicate is a boolean formula using linear-arithmetic expressions and equality with uninterpreted functions.
The \predicateCPA\ \cite{BeyerBook} \cite{Beyer2008} uses predicate abstraction \cite{Ball2001} to compute abstract states from a formula $\phi$ and a set $\pi$ of predicates (the precision).
Two different kinds of predicate abstraction exist:
The cartesian predicate abstraction $(\phi)^{\pi}_C$ is the strongest conjunction of predicates from $\pi$ that is implied by $\phi$.
The boolean predicate abstraction $(\phi)^{\pi}_B$ is the strongest boolean combination of predicates from $\pi$ that is implied by $\phi$.
In this work, we will only look at cartesian predicate abstraction because of its greater simplicity.
For a set $r \subseteq \pi$, $\varphi_r$ denotes the conjunction of all predicates in $r$, with $\varphi_{\{\}} = true$.

The \predicateCPA\ $\predCPA = (D_\predCPA, \Pi_\predCPA, \transfer_\predCPA, \cpaMerge^{sep}, \cpaStop^{sep}, \singletonPrec)$ consists of:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item
The abstract domain
	$D_\predCPA = (C, \predicatelattice, \concretization)$ with concrete states $C$, the semi-lattice $\predicatelattice$ and the concretization function $\concretization$.
	The semi-lattice is defined by $\predicatelattice = (2^P, \top_\predCPA, \bot, \lesserEqual, \join)$.
	Each abstract state is a finite subset $r \in P$ of predicates, with $P$ denoting the set of quantifier-free predicates over program variables $X$.
	An abstract state can be interpreted as the conjunction of all its predicates. $\top_\predCPA = \varnothing$ is an abstract state without any constraints (\emph{true}) and represents all possible concrete states.
	The bottom element $\bot = \{false\}$ represents no concrete state. A state $r$ is less or equal another state $r'$, if $r$ contains all predicates of $r'$, formally $r \lesserEqual r'$ if $r \supseteq r'$.
	The join of two states $r, r'$ is defined by $r \join r' = r \cap r'$.

	The concretization function $\concretization$ is defined by $\llbracket r \rrbracket = \{ c \in C |\ c \satisfies \varphi_r\}$.

\item
The precision type $\Pi_\predCPA = 2^P$ describes the precision of an abstract state as a set of predicates. If predicate $p \in P$ is in a precision $\pi$, $p$ is tracked by the analysis when $\pi$ is used.

\item
The transfer relation $\transfer_\predCPA$ has the transfer $r \gtransfer_\predCPA (r', \pi)$ if $\strongestPost(\varphi_r, g)$ is satisfiable
	and $r'$ is the largest set of predicates from $\pi$ so that $\varphi_r \Rightarrow \weakestPre(p, g)$ for each $p \in r'$.
	The operations $\strongestPost(\varphi, g)$ and $\weakestPre(\varphi, g)$ describe the strongest post-condition and the weakest pre-condition for a formula $\varphi$ and an operation $g$.
	They are defined such that
	\[\llbracket \strongestPost(\varphi, g) \rrbracket = \{c' \in C |\ \exists c \in C : c \gtransfer c' \logicAnd c \satisfies \varphi \}\] and
	\[\llbracket \weakestPre(\varphi, g) \rrbracket = \{c \in C |\ \exists c' \in C : c \gtransfer c' \logicAnd c' \satisfies \varphi \}.\]

\item
The already mentioned merge operator $\cpaMerge^{sep}$, defined as $\cpaMerge^{sep}(r, r', \pi) = r'$ for all $r, r' \in \predicatelattice$.

\item
The already mentioned termination check $\cpaStop^{sep}$, defined as $\cpaStop^{sep}(r, R, \pi) = \exists r' \in R : r \lesserEqual r'$.

\item
The precision adjustment $\singletonPrec$ that does not change anything: $\singletonPrec(r, \pi, R) = (r, \pi)$.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ValueAnalysisCPA}\label{sec:valueAnalysis}
The \valueAnalysisCPA\ \cite{Beyer2013} tracks integer values for all program variables explicitly.
It does so by using \emph{abstract variable assignments} \cite{Beyer2013}. An abstract variable assignment $v: X \partialFunc \integerset \cup \{\bot\}$ is a partial function that maps program variables $x \in X$ to integer values - if their assignment is known - or to $\bot$, if no possible value assignment exists.
An abstract variable assignment $v$ is \emph{contradicting} if $v(x) = \bot$ for any $x \in \defRange(v)$.
For two abstract variable assignments $v$ and $v'$, $v$ is \emph{implied} by $v'$, that is $v' \Rightarrow v$, if $v'$ is contradicting or if $\defRange(v') \subseteq \defRange(v)$ and for each variable $x \in \defRange(v) \cap \defRange(v') : v(x) = v'(x)$.
The \emph{conjunction} $v \logicAnd v'$ is defined as
\[(v \logicAnd v')(x) = \begin{dcases}
	\bot & \text{ if } x \in \defRange(v) \cap \defRange(v') \text{ and } v(x) \neq v'(x)\\
	v(x) & \text{ if } x \in \defRange(v)\\
	v'(x) & \text{ if } x \in \defRange(v')
\end{dcases}\]

We define the \emph{definition range} of a partial function $f$ as $\defRange(f) = \{ x |\ \exists y : (x, y) \in f \}$ and
the \emph{restriction} of a partial function $f$ to a new definition range $Y$ as $f_\restrictedTo{Y} = f \cap ( Y \times (\valueset \cup \{ \bot \}))$.

The \valueAnalysisCPA\ $\valCPA = (D_\valCPA, \Pi_\valCPA, \transfer_\valCPA, \cpaMerge^{sep}, \cpaStop^{sep}, \singletonPrec)$ consists of the following components:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item
The abstract domain $D_\valCPA = (C, \vallattice, \concretization)$ contains the set $C$ of possible concrete states, the semi-lattice $\vallattice$ and the concretization function $\concretization$.
	The semi-lattice $\vallattice = (\valAssignment, \top_\valCPA, \bot, \lesserEqual, \join)$ consists of the set $\valAssignment = X \partialFunc \valueset$ of abstract variable assignments,
	with $X$ being the set of program variables and $\valueset = \integerset \cup \{ \bot_\valueset \}$ the set of integer values and the bottom element.
	The top element $\top_\valCPA$ of the abstract domain is defined as $\top_\valCPA = \varnothing$. It represents an unknown assignment for all program variables.
	The bottom element $\bot$ is defined as $\bot(x) = \bot_\valueset$ for all $x \in X$.
	It represents an impossible variable assignment, that is a state that cannot be reached in the program execution.
	The less-or-equal operator $\lesserEqual\ \subseteq \valAssignment \times \valAssignment$ defines $v \lesserEqual v'$ if $\defRange(v') \subseteq \defRange(v)$ and for all $x \in \defRange(v'): v(x) = v'(x)$ or $v(x) = \bot_\valueset$.
	This means that a state $v$ is less or equal a state $v'$ if $v$ contains all variable assignments of $v'$ or restricts them even further.

	The join operator $\join$ defines the least upper bound of two abstract variable assignments, but is never used in our configuration.
	
	The concretization function $\concretization$ assigns to each abstract state $v$ the concrete states it represents, $\llbracket v \rrbracket = \{ c \in C |\ c(x) = v(x) \text{ for all } x \in \defRange(v)\}$.
	If an abstract state $v$ contains an impossible variable assignment, that is $v(x) = \bot_\valueset$ for any $x \in \defRange(v)$, then it represents no concrete state: $\llbracket v \rrbracket = \varnothing$.

\item
The set of precisions $\Pi_\valCPA = L \rightarrow 2^X$. A precision $\pi \in \Pi_\valCPA$ specifies for each program location $l \in L$ a subset of program variables of $X$ that are tracked at this location.

\item
The transfer relation $\transfer_\valCPA$ has the transfer $v \gtransfer_\valCPA (v', \pi)$ if one of the following is true:
	\begin{enumerate}[label=\alph*)]
	\item $g = (\cdot, \assume(p), \cdot)$ and for all $x \in \defRange(v')$:
		\[ v'(x) = \begin{dcases}
			\bot_\valueset & \text{ if } \exists y \in X : v(y) = \bot_\valueset \text{ or } p_\using{v} \text{ unsatisfiable}\\
			c & \text{ if $c$ is the only satisfying assignment of $p_\using{v}$ for $x$}\\
			v(x) & \text{ if none of the above and } x \in \defRange(v)
		\end{dcases}\]
		$p_\using{v}$ is the interpretation of a predicate $p$ using the known variable assignments of $v$, that is
		$p_\using{v} = p \logicAnd \biglogicAnd\limits_{x \in \defRange(v), v(x) \in \integerset}  x = v(x) \logicAnd \neg \exists x \in \defRange(v) : v(x) = \bot_\valueset$.
	\item $g = (\cdot, w \assign exp, \cdot)$ and
		\[ v'(x) = \begin{dcases}
			exp_\using{v} & \text{ if } x = w \text{ and } exp_\using{v} \neq \top_\valueset\\
			v(x) & \text{ if } x \neq w \text{ and } x \in \defRange(v)\\
		\end{dcases}\]
		$exp_\using{v}$ denotes the interpretation of an expression $exp$ using the values of abstract variable assignment $v$, that is
		\[exp_\using{v} = \begin{dcases}
			\bot_\valueset & \text{ if } \exists y : v(y) = \bot_\valueset\\
			\top_\valueset  & \parbox[t]{.6\textwidth}{if $y \not\in \defRange(v)$ for some $y \in X$ that occurs in $exp$}\\
			c & \parbox[t]{.6\textwidth}{ otherwise, where expression $exp$ is evaluated to $c$ after replacing each occurrence of variable $x \in \defRange(v)$ in $exp$ with $v(x)$}
		\end{dcases}\]
		with $\top_\valueset$ denoting an unknown value.
	\end{enumerate}

\item
The merge operator $\cpaMerge^{sep}$. That means that no merge is performed. This is the only aspect in which \constantpropagationCPA\ \cite{BeyerBook} and \valueAnalysisCPA\ differ.

\item
The termination check $\cpaStop^{sep}$, which checks every abstract state individually.

\item
The precision adjustment $\singletonPrec$ that does not change anything: $\singletonPrec(v, \pi, R) = (v, \pi)$.
Since we only track the program location in the \locationCPA, a composite precision adjustment has to handle the correct adjustment of abstract states to precisions of $\Pi_\valCPA$.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\SymbolicValueAnalysisCPA}\label{sec:symValCPA}
The \symbolicValueAnalysisCPA\ (introduced in \cite{Lemberger2015} without dynamic precision adjustment and using a different less-or-equal operator) is an extension to the \valueAnalysisCPA. It introduces \emph{symbolic values} to handle non-deterministic values and expressions of unknown value.

The \symbolicValueAnalysisCPA\ $\symValCPA = (D_\symValCPA, \Pi_\symValCPA, \transfer_\symValCPA, \cpaMerge_\symValCPA, \cpaStop^{sep}, \singletonPrec)$ consists of:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item The abstract domain $D_\symValCPA = (C, \symvallattice, \concretization)$ with the set $C$ of concrete states,
	the semi-lattice $\symvallattice$ and
	the concretization function $\concretization$.
	The semi-lattice $\symvallattice = (\symvalAssignment, \top_\symValCPA, \bot, \lesserEqual, \join)$ is defined by
	the set of abstract symbolic value assignments $\symvalAssignment = X \partialFunc \symvalset$ mapping program variables in its definition range to values of
	$\symvalset = \integerset \cup \symValues \cup \{ \bot_\valueset \}$.
	The value range of an abstract variable assignment of the type $\symvalAssignment$ consists of the set $\integerset$ of concrete integer values,
	the set $\symValues$ of symbolic values and the bottom element $\bot_\valueset$, which represents an impossible variable assignment.
	$\symValues = \symIds \cup \symExpressions$ consists of \emph{symbolic identifiers} $\symIds$ and \emph{symbolic expressions} $\symExpressions$.
	Each expression that contains at least one symbolic identifier is a symbolic expression.
	The definition range of an abstract variable assignment of $\symvalAssignment$ consists of all program variables whose value is known as either a concrete value (of $\integerset$),
	a symbolic value (of $\symValues$) or as invalid ($\bot_\valueset$).
	The top element $\top_\symValCPA = \varnothing$ represents no known assignment.

  The less-or-equal operator is equal to the one of the \valueAnalysisCPA, but implicitly considers symbolic values:
	For two abstract states $v, v' \in \symvalAssignment$, $v$ is less or equal to $v'$, i.e. $v \lesserEqual v'$, if $\defRange(v') \subseteq \defRange(v)$ and for all $x \in \defRange(v'): v(x) = v'(x)$ or $v(x) = \bot_\valueset$.
	Note that with this operator $v' \lesserEqual v \Rightarrow \llbracket v' \rrbracket \subseteq \llbracket v \rrbracket$, but in general $\llbracket v' \rrbracket \subseteq \llbracket v \rrbracket \not\Rightarrow v' \lesserEqual v$.

  In our previous work \cite{Lemberger2015}\ we used a more complex less-or-equal operator, using the semantics of the \valueAnalysisCPA\ for concrete values only, and defining a new behaviour for symbolic values. We defined it as follows:
  $v \lesserEqual' v'$, if all of the following conditions hold:
  (a) $v'$ must only contain value assignments also present in $v$, that is $\defRange(v') \subseteq \defRange(v)$,
  (b) for every concrete or invalid assignment of $v$, $v'$ must contain the same or a weaker one,
  that means \[\forall x \in \defRange(v') : v(x) \in \integerset \cup \{\bot_\valueset\} \Rightarrow v'(x) = v(x) \logicOr v(x) = \bot_\valueset\]
  and 
	(c) a bijective function $\aliasFunc : \symIds \rightarrow \symIds$ exists that maps each symbolic identifier of $\symIds$ to another symbolic identifier, so that
	$\forall x \in \defRange(v') : v'(x) \in \symValues \Rightarrow v(x)$ results from $v'(x)$ by replacing all $i \in \symIds$ occurring in $v'(x)$ with $\aliasFunc(i)$.

This operator can result in wrong behaviour when used in conjunction with the \constraintsCPA,
so we will not use it in this work.
An example for its wrong behaviour will be presented in Section~\ref{sec:leqOperators}.
  %This operator performs correctly when used without CEGAR. But when using the \symbolicValueAnalysisCPA with this aliasing operator in composition with the \constraintsCPA and CEGAR, it is possible that wrong results are computed. In addition, if the \constraintsCPA uses a less-or-equal operator that uses an $\aliasFunc$ function like the above one, the analysis can behave incorrectly even without CEGAR.
%These two points will be illustrated in Section~\ref{sec:leqOperators}.
%Because of this error-proneness, we will not use the aliasing less-or-equal operator in this work.

	%It can be thought of simpler or more precise less-or-equal operators. Such operators will be examined later.
	%Here, we use this operator (with some fixes to its origin) simply because it was used in our previous work \cite{Lemberger2015}.


	The join $\join : \symvalAssignment \times \symvalAssignment$ is defined as
	\[(v \join v')(x) = \begin{dcases}
		v(x) & \text{ if } v(x) = v'(x)\\
		\bot_\valueset & \text{ if } v(x) = \bot_\valueset \text{ or } v'(x) = \bot_\valueset
	\end{dcases}\]
	for all $x \in \defRange(v \join v')$.

\item The precision type $\Pi_\symValCPA = L \rightarrow 2^X$. Just like $\Pi_\valCPA$, a precision $\pi \in \Pi$ contains for each program location all program variables of $X$ that are tracked at this location.

\item The transfer relation $\transfer_\symValCPA$ contains the transfer $v \gtransfer_\symValCPA v''$, if one of the following conditions is true:
	\begin{enumerate}[label = \alph*)]
		\item $g = (\cdot, \assume(p), \cdot)$, $p_\using{v}$ is satisfiable and for all $x \in \defRange(v'')$
			\[ v''(x) = \begin{dcases}
				c & \parbox[t]{.6\textwidth}{ if $c$ is the only satisfying assignment for $p_\using{v}$ and $x \not\in \defRange(v)$}\\
				y & \parbox[t]{.6\textwidth}{ if $x \not\in \defRange(v)$ and $x$  appears in $p$. $y \in \symIds$ is a new symbolic values that has not been used in any other state before}\\
				v(x) & \text{ if none of the above and } x \in \defRange(v)
			\end{dcases}\]
			$p_\using{v}$ performs an over-approximation in this case, as variables with a symbolic assignment are not considered.
			Reminder: \[p_\using{v} = p \logicAnd \biglogicAnd\limits_{x \in \defRange(v), v(x) \in \integerset}  x = v(x) \logicAnd \neg \exists x \in \defRange(v) : v(x) = \bot_\valueset\]

		\item $g = (\cdot, w \assign exp, \cdot)$ and
			\[ v''(x) = \begin{dcases}
				exp_\using{v'} & \text{ if } x = w\\
				v'(x) & \text{ if } x \in \defRange(v) \text{ and } x \neq w
			\end{dcases}\]
			with
			\[v'(x) = \begin{dcases}
				y & \parbox[t]{.6\textwidth}{if $x \not \in \defRange(v)$ and $x$ appears in $exp$. $y \in \symIds$ is a new symbolic identifier that has not been used in any other state before}\\
				v(x) & \text{ if } x \in \defRange(v)
			\end{dcases}\]
			and $exp_\using{v'}$ defined as before. If any symbolic value occurs in $exp$ after replacing all occurences $x \in X$ in $exp$ with $v'(x)$,
			the expression is only partially evaluated. In this case $exp_\using{v'} \in \symValues$.
		\item $v'' = \top_\symValCPA$.
	\end{enumerate}

\item The use of $\cpaMerge_\symValCPA = \cpaMerge^{sep}$ means that no merge of abstract states is performed.
\item The termination check $\cpaStop^{sep}$ already mentioned considers every state independently when checking for coverage.

\item
The precision adjustment $\singletonPrec$ that does not change anything: $\singletonPrec(v, \pi, R) = (v, \pi)$. We rely on a \compositeCPA\ to perform precision adjustment, as a location is needed.

%Given an abstract state $v$ and a precision $\pi$, all abstract assignments of variables that do not occur in $\pi$ are removed from $v$. This is done by restricting the partial function: $\cpaPrec_\valCPAPlus(v, \pi, R) = (v_\restrictedTo{\pi}, \pi)$. The given precision is returned as it is.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\ConstraintsCPA} \label{sec:constraintsCPA}
The \constraintsCPA\
(introduced in \cite{Lemberger2015} without dynamic precision adjustment and with a less-or-equal operator using an $\aliasFunc$ function)
tracks constraints (i.e. boolean formulas) on symbolic identifiers created by assume edges.
For this, it relies on the values provided by the \symbolicValueAnalysisCPA\ to partially evaluate assume edges and create constraints out of them.
The \constraintsCPA\ $\constrCPA = (D_\constrCPA, \Pi_\constrCPA, \transfer_\constrCPA, \cpaMerge_\constrCPA, \cpaMerge^{sep}, \singletonPrec)$ is defined by:
\begin{enumerate}[leftmargin=*,label=\arabic*.]
\item The abstract domain $D_\constrCPA = (C, \constraintslattice, \concretization)$,
	which consists of concrete states $C$, the semi-lattice $\constraintslattice$ and the concretization function $\concretization$.
	
	The abstract states described by $\constraintslattice = (2^\constraintsset, \top_\constrCPA, \bot, \lesserEqualSub, \join)$ are subsets of the set $\constraintsset$ of all possible boolean expressions over the possible values of the \symbolicValueAnalysisCPA, $\symvalset$, and program variables, $X$. This includes concrete and symbolic values. An abstract state $a \subseteq \constraintsset$ can be interpreted as the conjunction of all its constraints, where each symbolic identifier $i \in \symIds$ is handled as a variable.
	The top element $\top_\constrCPA = \varnothing$ contains no constraints (it represents $true$). The bottom element $\bot$ represents a program state that can never be reached. It represents $false$.
$\lesserEqualSub$ is defined in the following way:
For two given states $a, a' \subseteq \constraintsset$, $a$ is less or equal $a'$, that is $a \lesserEqualSub a'$, if $a$ contains all constraints of $a'$, that is $a \supset a'$.

In \cite{Lemberger2015}\ we used a less-or-equal operator using an $\aliasFunc$ function like the \symbolicValueAnalysisCPA\ did, but we will not do so in this work because it does not always work with CEGAR for the same reasons as the \symbolicValueAnalysisCPA's aliasing less-or-equal operator.
%a bijective function $\aliasFunc : \symIds \rightarrow \symIds$ exists, so that $a'' \subseteq a$ with $a''$ resulting from $a'$ by replacing all symbolic identifiers $i \in \symIds$ occurring in the constraints of $a'$ with $\aliasFunc(i)$.
	The join $\join$ computes the least upper bound of two abstract states, but is never used.

	The concretization function $\concretization$ maps an abstract state to all concrete states that satisfy its constraints:
	\[ \llbracket a \rrbracket = \{ c \in C |\ c \satisfies \varphi_a \} \]
	with $\varphi_a$ denoting the conjunction of all predicates in $a$, $\varphi_a = \biglogicAnd\limits_{p \in a} p$.

\item
The set $\Pi_\constrCPA = L \rightarrow 2^{\goodconstraintsset}$ of precisions. Each precision $\pi \in \Pi_\constrCPA$ contains for each program location $l \in L$ all tracked constraints, with $\goodconstraintsset \subseteq \constraintsset$ being the set of all possible boolean expressions over $\symvalset$.
The constraints of $\goodconstraintsset$ do not contain any program variables, but the only variables occuring in them are symbolic identifiers of $\symIds$.

A second option is to use the precision $\Pi_\symValCPA = L \rightarrow 2^X$ of the \symbolicValueAnalysisCPA.
A constraint $p$ is tracked by $\pi \in \Pi_\symValCPA$ at a location $l$, if $\pi(l)$ contains all program variables $p$ originated from.

Example: If $p = s1 > s2 + 5$ with $s1, s2 \in \symIds$ was created from an edge $\assume(a > b)$ by using an abstract variable assignment $v = \{ (a, s1), (b, s2 + 5) \}$
and $\pi(l) = \{ a, b \}$, then $\pi$ contains all program variables $p$ originated from and it is tracked by $\pi$. 

\item The transfer relation $\transfer_\constrCPA$ contains the transfer $a \gtransfer_\constrCPA a'$ if one of the following is true:
	\begin{enumerate}[label=\alph*)]
		\item $g = (\cdot, \assume(p), \cdot)$, $a' = a \cup p$ and
			$a$ does not contain any variable $x \in X$.
			We just add the condition of the assume as a new constraint to the abstract state.
			Since $a$ may not contain any program variables we enforce that
			variables must always be replaced by concrete or symbolic values through strengthening before the next $\assume$ edge occurs.
			As two $\assume$ edges might follow each other, we even enforce immediate strengthening.
			Or,
		\item $g = (\cdot, w \assign e, \cdot)$ and $a' = a$. \ConstraintsCPA\ only cares about assume edges.
	\end{enumerate}
	
\item The merge operator $\cpaMerge_\constrCPA = \cpaMerge^{sep}$. No merge is performed when the control flow meets. We will introduce an alternative merge operator later on.
\item The termination check $\cpaStop^{sep}(e, R) = \exists e' \in R: e \lesserEqual e'$ considers every reached abstract state individually.

\item
The precision adjustment $\singletonPrec$ that does not change anything: $\singletonPrec(r, \pi, R) = (r, \pi)$.
Since we only track the program location in the \locationCPA, a composite precision adjustment has to handle the correct adjustment of abstract states to precisions of $\Pi_\constrCPA$.

\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\SymbolicExecutionCPA : Composition of Location CPA, Symbolic Value Analysis CPA and Constraints CPA}
The \symbolicExecutionCPA\ \cite{Lemberger2015}\ is the composition of \locationCPA, \symbolicValueAnalysisCPA\ and \constraintsCPA.
Besides connecting the \locationCPA\ to the other CPAs so abstract states can be mapped to a program location, its most important task is the definition of a strengthening operator that creates new constraints in the \constraintsCPA\ and checks their satisfiability.

The \symbolicExecutionCPA\ $\symExCPA$ is the \compositeCPA\ implied by the composition
$(\locCPA, \symValCPA, \constrCPA, \Pi_\symExCPA, \transfer_\symExCPA, \cpaMerge_\symExCPA, \cpaStop_\symExCPA, \cpaPrec_\symExCPA)$. It consists of:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item The three CPAs $\locCPA$, $\symValCPA$ and $\constrCPA$ and their abstract domains defined above.
\item The precision type $\Pi_\symExCPA = \Pi_\symValCPA \times \Pi_\constrCPA$ that contains the individual precisions of the \symbolicValueAnalysisCPA\ and \constraintsCPA. We do not need the precision of the \locationCPA\ because it never changes.
\item The transfer relation $\transfer_\symExCPA$.
	It contains the transfer $(l, v, a) \gtransfer_\symExCPA (l', v', a', \pi)$ if $l \gtransfer_\locCPA (l', \singletonPrecision)$, $v \gtransfer_\symValCPA (v', \pi_\symValCPA)$, if:
	\begin{enumerate}[label=\alph*)]
		\item $g = (\cdot, \assume(p), \cdot)$ and $\strengthenOp{\constrCPA}{\symValCPA}(a'', v') = a'$ is defined, with $a \gtransfer_\constrCPA (a'', \pi_\constrCPA)$, or

		\item $g = (\cdot, w \assign e, \cdot)$ and $a \gtransfer (a, \pi_\constrCPA)$,
	\end{enumerate}
	and if $\pi = (\singletonPrecision, \pi_\symValCPA, \pi_\constrCPA)$.

	It uses the strengthening operator $\strengthenOp{\constrCPA}{\symValCPA} : 2^\constraintsset \times V_\symValCPA \rightarrow \goodconstraintsset$ that strengthens an abstract state of the \constraintsCPA\ by using an abstract state of the \symbolicValueAnalysisCPA.
	$\strengthenOp{\constrCPA}{\symValCPA}(a'', v) = a'$ is defined if the following conditions are true:
	\begin{enumerate}[label=\alph*)]
		\item $a'$ results from $a''$ by first replacing all program variables $x$ occurring in the constraints of $a''$ by their abstract value assignment $v(x)$ (denoted as $a''_\using{v}$) and then removing all constraints that
			still contain program variables:
			\[ a' = a''_\using{v} \cap \goodconstraintsset.\]
			$v(x)$ can be a concrete or symbolic value as well as $\bot_\valueset$. We define a constraint containing $\bot_\valueset$ as $false$, though, and as such, the strengthen operator is not defined if $\bot_\valueset$ is occurs.
		\item  $\varphi_{a'}$ is satisfiable.
	\end{enumerate}

\item
The merge operator
	$\cpaMerge_\symExCPA = \mergeAgree$ uses the merge operators of each CPA on the corresponding abstract states individually, if, after the merge, every component's state is less or equal the both previous states. Otherwise no merge is performed.

\item
The stop operator $\cpaStop_\symExCPA$
	uses the stop operators of each CPA on the corresponding abstract state and reached set individually. It only returns $true$ if all of them return $true$.

\item
The precision adjustment operator $\cpaPrec_\symExCPA$ performs precision adjustment on the abstract state of the \symbolicValueAnalysisCPA\ and the \constraintsCPA.
It uses the abstract state of the \locationCPA\ in both cases to get the tracked program variables/constraints for the current location.
\[ \cpaPrec_\symExCPA(l, v, a, \pi_\times, R) = (l, \auxiliaryPrec_\symValCPA(v, l, \pi_\symValCPA), \auxiliaryPrec_\constrCPA(a, l, \pi_\constrCPA), \pi_\times) \]
with $\pi_\times = (\pi_\symValCPA, \pi_\constrCPA)$.
The precision adjustment of the symbolic value state removes the abstract variable assignments of all program variables that are not tracked by $\pi \in \Pi_\symValCPA$ at the current location.
\[\auxiliaryPrec_\symValCPA(v, l, \pi) = v_\restrictedTo{\pi(l)}.\]
The precision adjustment of the constraints state depends on the type of precision used for the \constraintsCPA:
The adjustment $\auxiliaryPrec_\constrCPA$  removes all constraints that are not tracked at the current location.
Its concrete implementation depends on the used precision type of the \constraintsCPA:
If $\Pi_\constrCPA$ is used, which stores all tracked constraints explicitely, the adjustment is defined as
\[\auxiliaryPrec_\constrCPA(a, l, \pi)= a \cap \pi(l).\]
If $\Pi_\symValCPA$ is used, which only stores the program variables constraints may originate from, the adjustment deletes all constraints that originate from at least one program variable that does not occur in $\pi(l)$ with $\pi$ being the current precision.
\end{enumerate}
