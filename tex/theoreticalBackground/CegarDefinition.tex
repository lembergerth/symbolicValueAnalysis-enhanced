\subsection{Basic CEGAR and its algorithm}
\subsubsection{CEGAR and interpolation in general}
Counterexample-guided abstraction refinement (CEGAR) \cite{Clarke2003} is a technique to find an abstraction that contains as few information as possible while retaining the possibility to prove or disprove a program's correctness.
This technique can greatly reduce the number of abstract states in a program's analysis and is considered ''the most general and flexible for handling the state explosion problem,''\cite{Clarke2003}\ the major problem we are facing with our \symbolicExecutionCPA.

The technique starts analysis with a coarse abstraction and refines it based on counterexamples. A counterexample is a witness of a property violation.\cite{Beyer2013}
If no error path is found by the analysis, it terminates and reports that no property violation exists.
If an error path is found, it is checked whether the path is feasible (i.e. a possible program execution) by repeating the analysis with full precision.
If the path is feasible, the analysis terminates and reports the found property violation.
If the error path is infeasible it was only found because the abstraction is too coarse. As a consequence, the abstraction is refined using the error path.
After this, the analysis starts again, using the new abstraction.

Since the problem of finding the coarsest possible refinement of an abstraction based on an error path is NP-hard, \cite{Clarke2003}\ good heuristics have to be used to find good refinements.
Interpolation \cite{Henzinger2004}\ is one such technique in a boolean context that is used for refinement of both the \predicateCPA\ and \valueAnalysisCPA.

\subsubsection{CEGAR and interpolation in the context of configurable software verification}
To apply CEGAR and interpolation to configurable software verification and value analysis in particular, which is not based on formulas, but abstract value assignments, some modifications have to be made.
First, the notion of CPAs and the CPA algorithm is extended to allow the weakening and strengthening of abstract states  based on some precision, which represents the ''abstraction'' referred to previously.
To do so, a CPA has to define a precision and precision adjustment and its other components have to consider the current precision.
A CPA using dynamic precision adjustment \cite{Beyer2008} \[ \cpaPlus = (D, \Pi, \transfer, \cpaMerge, \cpaStop, \cpaPrec ) \] consists of:
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item An abstract domain $D = (C, \semilattice, \concretization)$ with concrete states $C$, the semi-lattice $\semilattice = (E, \top, \bot, \lesserEqual, \join)$ and the concretization function $\concretization$, as already defined.
\item A set of \emph{precisions} $\Pi$. A precision $\pi \in \Pi$ defines the information that should be kept in the abstract states after each transfer.
\item A transfer relation $\transfer : E \times (E \times \Pi)$ that not only computes the possible successors of an abstract state of $E$, but also their precisions. The precision computed by the transfer relation will be used on the computed abstract state in the new CPA algorithm shown below.
\item A merge operator $\cpaMerge : E \times E \times \Pi \rightarrow E$ that uses an abstract state and a precision to weaken or strengthen an abstract state.
\item A termination check $\cpaStop : E \times 2^{E} \times \Pi \rightarrow \booleanset$ that computes whether a given abstract state is covered by a given set of abstract states, using a specific precision.
\item A \emph{precision adjustment} $\cpaPrec : E \times \Pi \rightarrow E \times \Pi$ with $E$ being the elements of the semi-lattice of $D$. This operator computes a new abstract state and precision based on a given abstract state and precision.
\end{enumerate}
It is easy to convert an existing CPA without precision adjustment into one that fits the above type, if no precision adjustment is wanted (e.g. in the \locationCPA\ precision adjustment would not make any sense):
\begin{enumerate}[leftmargin=*, label=\arabic*.]
\item Keep the abstract domain as it is.
\item Introduce a single precision $\singletonPrecision$. It will only be used as a dummy.
\item Extend the existing transfer relation to always return $\singletonPrecision$ in addition to its abstract states:
	$e \transfer (e', \singletonPrecision)$ if  $e \transfer' e'$ exists, with $\transfer'$ being the old transfer relation.
\item Adjust the type of operators $\cpaMerge$ and $\cpaStop$, but keep their behaviour without regarding the precision given to them.
\item Define the precision adjustment $\cpaPrec$ so it does not change anything: $\cpaPrec(e, \pi) = (e, \pi)$. 
\end{enumerate}
Keeping to this scheme, the common operators for $\cpaMerge$ and $\cpaStop$ are defined as:
\[\begin{aligned}
& \cpaMerge^{sep} (e, e', \pi) = e'\\
& \cpaMerge^{join} (e, e', \pi) = e \join e'\\
& \cpaStop^{sep} (e, R, \pi) = \exists e' \in R : e \lesserEqual e'\\
& \cpaStop^{join} (e, R, \pi) = e \lesserEqual \bigjoin\limits_{e' \in R} e'
\end{aligned}\]

\begin{algorithm}[t]
\caption{$CPA(\cpaPlus, R_0, W_0)$, adapted from \cite{Beyer2013}}
\label{alg:cpaPlus}
\begin{algorithmic}[1]

\Input a CPA $\cpaPlus = (D, \Pi, \transfer, \cpaMerge, \cpaStop, \cpaPrec)$,
	    a set $R_0 \subseteq (E \times \Pi)$ of initial states with their precision and
	    a subset $W_0 \subseteq R_0$ of frontier abstract states with their precision,
	    with $E$ being the set of elements of $D$
\Output a set of abstract states reachable from $R_0$ with their precision and
	   a subset of frontier abstract states with their precision
\Variables \reachedSet\ and \waitlistSet , both sets of elements of $E \ times \Pi$
\State $\reachedSet \assign R_0$
\State $\waitlistSet \assign W_0$
\While{$\waitlistSet \neq \varnothing$}
	\State choose $(e, \pi)$ from \waitlistSet
	\State remove $(e, \pi)$ from \waitlistSet
	\ForAll{$e'$ with $e \transfer (e', \pi)$}
		\State $(\hat{e}, \hat{\pi}) \assign \cpaPrec(\hat{e}, \pi, \reachedSet)$ \Comment Precision adjustment \label{alg:cpaPlus:precAdj}
		\If{$\isTargetState{\hat{e}}$}
			\State %empty state so that the return statement below is in a new line
			\Return $(\reachedSet \cup \{ (\hat{e}, \hat{\pi}) \},\ \waitlistSet)$
		\EndIf
		\ForAll{$(e'', \pi '') \in \reachedSet$}
			\State $e_{new} \assign \cpaMerge(\hat{e}, e'', \hat{\pi})$ \Comment Combine with existing state
			\If{$e_{new} \neq e''$}
				\State $\waitlistSet \assign (\waitlistSet \cup \{ (e_{new}, \hat{\pi}) \}) \setminus \{ (e'',\pi '') \}$
				\State $\reachedSet \assign (\reachedSet \cup \{ (e_{new}, \hat{\pi}) \}) \setminus \{ (e'', \pi '') \}$
			\EndIf
		\EndFor
		\If{$\neg \cpaStop(e', \{ e |\ (e, \cdot) \in \reachedSet \}, \hat{\pi})$}
			\State $\waitlistSet \assign \waitlistSet \cup \{ (\hat{e}, \hat{\pi}) \}$
			\State $\reachedSet \assign \reachedSet \cup \{ (\hat{e}, \hat{\pi}) \}$
		\EndIf
	\EndFor
\EndWhile\\ 
\Return $(\reachedSet, \varnothing)$ \Comment Return reached set and the now empty waitlist
\end{algorithmic}
\end{algorithm}

In addition to this, the CPA algorithm (Algorithm \ref{alg:CPA}) is adjusted to use these new components.
Algorithm \ref{alg:cpaPlus} shows the modified version of the CPA algorithm. We not only add the precision adjustment (Line \ref{alg:cpaPlus:precAdj}), but also pass the algorithm the initial waitlist and initial reached set instead of just one initial state. This way it is possible to control at which state(s) the algorithm starts.
We use this so we can control at which point the analysis continues after a refinement was performed.

\begin{algorithm}[t]
\caption{$CEGAR(\cpaPlus, e_0, \pi_0)$, adapted from \cite{Beyer2013}}
\label{alg:cegar}
\begin{algorithmic}[1]
\Input a CPA $\cpaPlus = (D, \Pi, \transfer, \cpaMerge, \cpaStop, \cpaPrec)$ with dynamic precision adjustment,
	an initial abstract state $e_0 \in E$ with precision $\pi_0 \in \Pi$,
	with $E$ denoting the set of elements of the semi-lattice of $D$
\Output the verification result \safe\ or \unsafe
\Variables the sets \reachedSet\ and \waitlistSet\ of elements of $E \times \Pi$,
	      an error path $\sigma = \langle (op_1, l_1), ..., (op_n, l_n) \rangle$\\

\State $\reachedSet \assign \{ (e_0, \pi_0) \}$
\State $\waitlistSet \assign \{ e_0, \pi_0 \}$
\State $\pi \assign \pi_0$
\While{true}
	\State $(\reachedSet, \waitlistSet) \assign CPA(\cpaPlus, \reachedSet, \waitlistSet)$
	\If{$\waitlistSet = \varnothing$}
		\Return \safe
	\Else
		\State $\sigma \assign \extractErrorPath{\reachedSet}$
		\If{\isFeasible{$\sigma$}} \Comment error path feasible: report bug
			\State % empty state for new line after if
			\Return \unsafe 
		\Else \Comment error path infeasible: refine and restart from the beginning
			\State $\pi \assign \pi \cup \refine{\sigma}$
			\State $\reachedSet \assign (e_0, \pi)$
			\State $\waitlistSet \assign (e_0, \pi)$
		\EndIf
	\EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

Now that the CPA algorithm is able to use precisions created in a refinement procedure, we use it as a part of our complete CEGAR algorithm.
Algorithm \ref{alg:cegar} uses a CPA using dynamic precision adjustment $\cpaPlus$,
an initial state $e_0$
and an initial precision $\pi_0$
to compute whether a property violation exists.

First, the $CPA$ algorithm is used to compute a set of reached abstract states ($\reachedSet$) and a subset of this set that contains all reached abstract states that have not been handled yet ($\waitlistSet$).
If $\waitlistSet$ is empty, the $CPA$ algorithm has handled all reachable states without encountering any target state.
If this is the case, no property violation was found and the algorithm can return \safe.
Otherwise, an error path is extracted from the reached set.
If the error path is reported as feasible, a property violation exists or the algorithm is not able to prove that none exists. It returns \unsafe.
If the error path is infeasible, the current precision is too abstract.
It is refined based on the infeasible error path by using $\refineFunc : \Sigma \rightarrow \Pi$ with $\Sigma$ being the set of all error paths, so that it can prove its infeasibility.
After this, the reached set and waitlist are reset to their initial values and the algorithm repeats analysis with the refined precision.
It is important to notice that the return type of $\refineFunc$ has to be equal to the precision type $\Pi$ used in $\cpaPlus$.
Because of this, CPAs are not exchangeable without changing refinement, too, in general.
As we are interested in using CEGAR with the \symbolicExecutionCPA, which uses both linear arithmetics (\constraintsCPA ) and abstract variable assignments (\valueAnalysisCPA ),
we will first describe the existing refinement procedures of these two domains, as they are used in conjunction with the \predicateCPA\ and \valueAnalysisCPA, for example.

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Refinement in general
%%%%%%%%%%%%%%%%%%%%%%%%%%
For refinement, the priorly mentioned technique of interpolation is used to determine a location-specific precision that is strong enough for the CPA algorithm with precision adjustment to prove that a given error path is infeasible.
A boolean formula $\craigItp$ is a Craig interpolant \cite{Craig1957}\ for two boolean formulas $\prefix$ (called prefix) and $\suffix$ (called suffix), if the following three conditions are fulfilled:
\begin{enumerate}[label=\alph*)]
\item The prefix implies $\craigItp$, that is $\prefix \Rightarrow \craigItp$.
\item $\craigItp$ contradicts the suffix, that means $\craigItp \logicAnd \suffix$ is contradicting.
\item $\craigItp$ only contains variables occurring in \emph{both} prefix and suffix.
\end{enumerate}
It is proven that such an interpolant always exists in the domain of abstract variable assignments \cite{Beyer2013} as well as in the theory of linear arithmetics \cite{Craig1957}.

%\subsubsection{Refinement for the domain of abstract variable assignments}
The strongest-post operator $\strongestPostOp_{op}$ describes the semantics of an operation $op \in Ops$.
It is the analogy to the transfer relation in the domain of CPAs.
It maps a region of concrete states, implied by an abstract variable assignment, to the region of all concrete states that can be reached by executing $op$.
The semantics of a path $\sigma = \langle (l_1, op_1), ..., (l_n, op_n) \rangle$ is defined as the consecutive application of the strongest-post operator to its constraint sequence $\gamma_\sigma = \langle op_1, ..., op_n \rangle$:
$\strongestPostOp_{\gamma_\sigma}(v) = \strongestPostOp_{op_n}(\strongestPostOp_{op_{n-1}} (...\ \strongestPostOp_{op_1}(v) ... ))$.
We use strongest-post operators during interpolation and refinement to evaluate paths.

The strongest-post operator $\strongestPostOpExplicit_{op}$ is defined in the following way:
%\begin{enumerate}[label=\alph*)]
%\item
For an assignment operation $s \assign exp$, $\strongestPostOpExplicit_{s \assign exp}(v) = v_\restrictedTo{X \setminus \{ s \}} \logicAnd v_{s \assign exp}$ with $v_{s \assign exp} = \{ (s, exp_\using{v}) \}$ and $exp_\using{v}$ denoting the evaluation of $exp$ using the abstract variable assignment $v$, as defined in Section \ref{sec:valueAnalysis}.
%\item
For an assume operation $\assume(p)$, 
	$\strongestPostOpExplicit_{\assume(p)}(v) = v'$ with 
	\[ v'(x) = \begin{dcases}
		\bot & \text{ if } \exists y \in \defRange(v) : v(y) = \bot \text{ or } p_\using{v} \text{ is unsatisfiable}\\
		c & \text{ if $c$ is the only satisfying assignment of $p_\using{v}$ for $x$}\\
		v(x) & \text{ if none of the above and } x \in \defRange(v)
	\end{dcases}\]
	with $p_\using{v}$ as defined in Section \ref{sec:valueAnalysis}.
%\end{enumerate}

%\subsubsection{Interpolation for abstract variable assignments}
\begin{algorithm}[t]
\caption{$\interpolateExplicit(\prefix, \suffix)$, adapted from \cite{Beyer2013}}
\label{alg:interpolateExplicit}
\begin{algorithmic}[1]
\Input two constraint sequences $\prefix$ and $\suffix$, with $\prefix \logicAnd \suffix$ contradicting
\Output a constraint sequence $\Gamma$, which is an interpolant for $\prefix$ and $\suffix$
\Variables an abstract variable assignment $v$

\State $v \assign \strongestPostOpExplicit_\prefix(\varnothing)$
\ForAll{$x \in \defRange(v)$}
	\If{$\strongestPostOpExplicit_\suffix(v_\restrictedTo{\defRange(v) \setminus \{x\}})$ is contradicting}
		\State $v \assign v_\restrictedTo{\defRange(v) \setminus \{x\}}$ \Comment $x$ not relevant, should not occur in interpolant
	\EndIf
\EndFor
\State $\Gamma \assign \langle \rangle$
\ForAll{$x \in \defRange(v)$} \label{alg:interpolateExplicit:itpStart}
	\State $\Gamma \assign \Gamma \logicAnd \langle \assume(x = v(x))\rangle$
\EndFor\\ \label{alg:interpolateExplicit:itpFinish}
\Return $\Gamma$
\end{algorithmic}
\end{algorithm}

The algorithm for interpolation in the domain of abstract variable assignments is shown in Algorithm \ref{alg:interpolateExplicit}.
For a prefix $\prefix$ and a suffix $\prefix$, the abstract variable assignment $v$, that results from applying $\prefix$ to the initial abstract variable assignment $\varnothing$ is computed.
Next, for each variable assignment in $v$ it is checked whether the assignment is necessary to prove that $\suffix$ is contradicting.
If it is not, it can be removed from $v$.
After all variable assignments are checked, $v$ only contains variable assignments that are necessary to prove that $\suffix$ is contradicting.
From these, the interpolant is built (Lines \ref{alg:interpolateExplicit:itpStart} - \ref{alg:interpolateExplicit:itpFinish}).

\begin{algorithm}[t]
\caption{$\refineExplicit{\sigma}$, adapted from \cite{Beyer2015}}
\label{alg:refinementExplicit}
\begin{algorithmic}[1]
\Input infeasible error path $\sigma = \langle (op_1, l_1), ..., (op_n, l_n) \rangle$
\Output precision $\pi$
\Variables interpolating constraint sequence $\Gamma$
\State $\Gamma \assign \langle \rangle$
\State $\pi(l) \assign \varnothing$ for all program locations $l$
\For{$i \assign 1$ to $n - 1$}
	\State $\suffix \assign \langle op_{i+1}, ..., op_n \rangle$
	\State $\Gamma \assign \interpolateExplicit(\Gamma \logicAnd \langle op_i \rangle, \suffix)$ \Comment inductive interpolation \label{alg:refinementExplicit:interpolation}
	\State $\pi(l_i) \assign \extractPrecision{\Gamma}$
\EndFor\\
\Return $\pi$
\end{algorithmic}
\end{algorithm}

The interpolants produced are used in the refinement of the precision (Alg. \ref{alg:refinementExplicit}).
As the type of the precision can be chosen freely, we use a location-specific precision $\pi : L \rightarrow 2^X$ that returns for a program location $l \in L$ all program variables of $X$ which are relevant for the analysis at this location. This approach realizes the lazy abstraction technique \cite{Henzinger2002}.
The algorithm starts with an initial, empty interpolant $\Gamma$ and empty precision $\pi$ with $\pi(l) = \varnothing$ for all $l \in L$.
For each location $(l_i, op_i)$ on the error path, the suffix $\suffix$ of this location are set and the interpolant is computed inductively from the existing interpolant in conjunction with the current operation $op_i$ and the suffix (Line \ref{alg:refinementExplicit:interpolation}).
It is not only sufficient, but also required to use $\Gamma \logicAnd \langle op_i \rangle$ instead of the full prefix $\prefix = \langle op_1, ..., op_1 \rangle$. All information necessary for proving the infeasibility of the remaining error path is present here. The full prefix cannot be used as it has to be assured that the precision resulting from these consecutive interpolations proves the error path infeasible.

\subsubsection{Refinement for the domain of linear arithmetics}
\PredicateCPA\ uses a standard approach to refinement based on lazy abstraction and Craig interpolation.

These refinement procedures can be used in CEGAR (Alg. \ref{alg:cegar}) in combination with a CPA with precision adjustment that expects these precision types, like the \valueAnalysisCPA\ in combination with refinement for abstract variable assignments.

%\subsubsection{\ValueAnalysisCPA\ with precision adjustment}
%The \valueAnalysisCPA\ with dynamic precision adjustment \cite{Beyer2013} \[\valCPAPlus = (D_\valCPA, \Pi_\valCPAPlus, \transfer_\valCPAPlus, \cpaMerge^{sep}, \cpaStop^{sep}, %\cpaPrec_\valCPAPlus)\] is a CPA that can be, and is, used with the refinement for abstract variable assignments as described above.
%It consists of:
%\begin{enumerate}[leftmargin=*, label=\arabic*.]
%\item The abstract domain $D_\valCPA$ as defined in Section \ref{sec:valueAnalysis}.
%\item The set of precisions $\Pi_\valCPAPlus = L \rightarrow 2^X$. A precision $\pi \in \Pi_\valCPAPlus$ specifies a subset of program variables of $X$ that are tracked.
%\item The transfer relation $\transfer_\valCPAPlus$ contains the transfer $v \transfer_\valCPAPlus (v', \pi)$ if $v \transfer_\valCPA v'$.
%\item The merge operator $\cpaMerge^{sep}$ that performs no merging.
%\item The termination check $\cpaStop^{sep}$ that checks every state individually.
%\item The precision adjustment $\cpaPrec_\valCPAPlus$. Given an abstract state $v$ and a precision $\pi$, all abstract assignments of variables that do not occur in $\pi$ are removed from %$v$. This is done by restricting the partial function: $\cpaPrec_\valCPAPlus(v, \pi) = (v_\restrictedTo{\pi}, \pi)$. The given precision is returned as it is.
%\end{enumerate}

In this chapter, we gave an overview of all theoretical concepts that are necessary to describe our own work. We introduced the concept of configurable software verification and configurable program analyses (CPAs), a very versatile approach to automated software verification. We introduced different CPAs we use in this work and CEGAR with precision refinement for both linear arithmetics and abstract variable assignments, which we will combine when using CEGAR with the \symbolicExecutionCPA.
